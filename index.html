<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>canvas game</title>
    <link rel="stylesheet" href="index.css" />
  </head>
  <body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
  </body>
  <script>
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            // Player Object
            const player = {
                x: canvas.width / 2,
                y: canvas.height / 2,
                size: 40,
                speed: 3,
                angle: 0, // Forward direction (in radians)
                color: 'blue',
                health: 10,
            };

            // Projectiles Array
            let projectiles = [];

            // Handle player movement
            const keys = {};
            window.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;
            });
            window.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });

            // Create projectiles on space press
            function fireProjectile() {
                const { x, y, angle } = player;
                const size = 5;
                const speed = 5;
                projectiles.push({
                x: x + Math.cos(angle) * (player.size / 2), // Start at the tip of the player
                y: y + Math.sin(angle) * (player.size / 2),
                angle,
                size,
                speed,
                });
            }

            // Update projectiles
            function updateProjectiles() {
                projectiles = projectiles.filter(
                (p) => p.x > 0 && p.x < canvas.width && p.y > 0 && p.y < canvas.height // Remove off-screen projectiles
                );

                for (let p of projectiles) {
                p.x += Math.cos(p.angle) * p.speed;
                p.y += Math.sin(p.angle) * p.speed;
                }
            }

            // Draw projectiles
            function drawProjectiles() {
                for (let p of projectiles) {
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fillStyle = 'red';
                ctx.fill();
                ctx.closePath();
                }
            }

            // Handle player controls
            function updatePlayer() {
                  if (keys['w']) {
                    player.x += Math.cos(player.angle) * player.speed;
                    player.y += Math.sin(player.angle) * player.speed;
                  }
                  if (keys['s']) {
                    player.x -= Math.cos(player.angle) * player.speed;
                    player.y -= Math.sin(player.angle) * player.speed;
                  }
                  if (keys['a']) {
                    player.angle -= 0.05; // Rotate left
                  }
                  if (keys['d']) {
                    player.angle += 0.05; // Rotate right
                  }

                  // Boundaries check
                  player.x = Math.max(player.size / 2, Math.min(canvas.width - player.size / 2, player.x));
                  player.y = Math.max(player.size / 2, Math.min(canvas.height - player.size / 2, player.y));

                  // Fire projectile
                  if (keys[' ']) {
                    fireProjectile();
                    keys[' '] = false; // Prevent continuous firing
                  }
                }

            // Draw player
            function drawPlayer() {
                ctx.save();
                ctx.translate(player.x, player.y);
                ctx.rotate(player.angle);

                // Draw the square
                ctx.fillStyle = player.color;
                ctx.fillRect(-player.size / 2, -player.size / 2, player.size, player.size);

                // Draw forward marker
                ctx.beginPath();
                ctx.moveTo(0, -player.size / 2); // Forward point
                ctx.lineTo(0, player.size / 2); // Back line
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.restore();
            }

            // Ball objects
            let balls = [
                { x: 200, y: 200, radius: 20, vx: 2, vy: 3, color: 'blue' },
                { x: 400, y: 200, radius: 20, vx: -3, vy: 2, color: 'green' },
            ];


            // Particle system
            let particles = [];

            function createParticles(x, y, count = 50) {
                for (let i = 0; i < count; i++) {
                particles.push({
                    x,
                    y,
                    vx: Math.random() * 4 - 2, // Random horizontal speed
                    vy: Math.random() * 4 - 2, // Random vertical speed
                    life: 100, // Particle lifespan
                });
                }
            }

            // Update particle positions
            function updateParticles() {
                particles = particles.filter((p) => p.life > 0); // Remove dead particles
                for (let p of particles) {
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                }
            }

            // Draw particles
            function drawParticles() {
                for (let p of particles) {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 165, 0, ${p.life / 100})`; // Fade out
                ctx.fill();
                ctx.closePath();
                }
            }

            // Detect collision between two circles
            function isCircleColliding(a, b) {
            const dx = a.x - b.x;
            const dy = a.y - b.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < a.radius + b.radius;
            }

            // Detect collision between player and balls
            function isPlayerColliding(ball) {
                const dx = ball.x - player.x;
                const dy = ball.y - player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < ball.radius + player.size / 2;
            }

            // Handle collisions between balls
            function handleBallBallCollisions() {
                for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    if (isCircleColliding(balls[i], balls[j])) {
                    // Reverse velocities for simple collision response
                    const tempVx = balls[i].vx;
                    const tempVy = balls[i].vy;
                    balls[i].vx = balls[j].vx;
                    balls[i].vy = balls[j].vy;
                    balls[j].vx = tempVx;
                    balls[j].vy = tempVy;
                    }
                }
                }
            }

            // Handle collisions with player
            function handlePlayerCollisions() {
                balls.forEach((ball) => {
                    if (isPlayerColliding(ball)) {
                    player.health -= 2;

                    // Reverse ball direction
                    ball.vx *= -1;
                    ball.vy *= -1;

                    // Reset player if health is 0
                    if (player.health <= 0) {
                        player.health = 10;
                        player.x = canvas.width / 2;
                        player.y = canvas.height / 2;
                    }
                    }
                });
            }

            // Check for collision between two balls
            function isColliding(ball1, ball2) {
                let dx = ball1.x - ball2.x;
                let dy = ball1.y - ball2.y;
                let distance = Math.sqrt(dx * dx + dy * dy);
                return distance < ball1.radius + ball2.radius;
            }

            // Update ball positions and handle collisions
            // function updateBalls() {
            //     for (let i = 0; i < balls.length; i++) {
            //         let ball = balls[i];

            //         // Update position
            //         ball.x += ball.vx;
            //         ball.y += ball.vy;

            //         // Bounce off walls
            //         if (ball.x - ball.radius < 0 || ball.x + ball.radius > canvas.width) {
            //             ball.vx *= -1;
            //         }
            //         if (ball.y - ball.radius < 0 || ball.y + ball.radius > canvas.height) {
            //             ball.vy *= -1;
            //         }

            //         // Check for collisions with other balls
            //         for (let j = i + 1; j < balls.length; j++) {
            //             let otherBall = balls[j];
            //             if (isColliding(ball, otherBall)) {
            //                 // Simple velocity reversal on collision
            //                 ball.vx *= -1;
            //                 ball.vy *= -1;
            //                 otherBall.vx *= -1;
            //                 otherBall.vy *= -1;

            //                 // Create particles at collision point
            //                 createParticles((ball.x + otherBall.x) / 2, (ball.y + otherBall.y) / 2);
            //             }
            //         }
            //     }
            // }
            function updateBalls() {
      balls.forEach((ball) => {
        ball.x += ball.vx;
        ball.y += ball.vy;

        // Bounce off walls
        if (ball.x - ball.radius < 0 || ball.x + ball.radius > canvas.width) {
          ball.vx *= -1;
        }
        if (ball.y - ball.radius < 0 || ball.y + ball.radius > canvas.height) {
          ball.vy *= -1;
        }
         // Check for collisions with other balls
                    for (let j = i + 1; j < balls.length; j++) {
                        let otherBall = balls[j];
                        if (isColliding(ball, otherBall)) {
                            // Simple velocity reversal on collision
                            ball.vx *= -1;
                            ball.vy *= -1;
                            otherBall.vx *= -1;
                            otherBall.vy *= -1;

                            // Create particles at collision point
                            createParticles((ball.x + otherBall.x) / 2, (ball.y + otherBall.y) / 2);
                        }
                    }
      });
    }
            // Draw balls
            function drawBalls() {
                for (let ball of balls) {
                    ctx.beginPath();
                    ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                    ctx.fillStyle = ball.color;
                    ctx.fill();
                    ctx.closePath();
                }
            }

            // Draw health
    function drawHealth() {
      ctx.fillStyle = 'black';
      ctx.font = '20px Arial';
      ctx.fillText(`Health: ${player.health}`, 10, 30);
    }

            // Main game loop
            function loop() {
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas

                //update game objects
                updatePlayer();
                updateBalls();
                updateParticles();
                updateProjectiles();
                handleBallBallCollisions();
                handlePlayerCollisions();

                //draw game objects
                drawPlayer();
                drawBalls();
                drawHealth();
                drawProjectiles();
                drawParticles();

                requestAnimationFrame(loop);
            }

            loop();
  </script>
</html>
