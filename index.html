<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>canvas game</title>
    <link rel="stylesheet" href="index.css" />
  </head>
  <body>
    <div id="container">
      <canvas id="gameCanvas" width="1000" height="1000"></canvas>
      <div id="errorMessage" class="hidden">Invalid attack used!</div>
      <div id="weapon" class="weaponBox"></div>
    </div>
  </body>
  <script type="module">
    import { meleeStrike } from "./character_attacks.js";
    const canvas = document.getElementById("gameCanvas");
    const weaponBox = document.getElementById("weapon");
    weaponBox.classList.add("green");
    const ctx = canvas.getContext("2d");
    let currentLevel = 1;

    let showError = false; // Boolean value to toggle the error message
    let lastErrorTime = 0; // Tracks the last time the error message was triggered
    let isPlayerDead = false; // Flag to prevent multiple executions when health drops to 0

    let marks = []; // Array to store marks
    // Ball objects
    let balls = [
      // {
      //   x: 200,
      //   y: 200,
      //   radius: 20,
      //   vx: 2,
      //   vy: 1,
      //   color: "blue",
      //   lastHit: 0,
      //   health: 10,
      // },
      // {
      //   x: 400,
      //   y: 200,
      //   radius: 20,
      //   vx: -3,
      //   vy: 5,
      //   color: "green",
      //   lastHit: 0,
      //   health: 10,
      // },
      // {
      //   x: 300,
      //   y: 200,
      //   radius: 20,
      //   vx: 5,
      //   vy: -2,
      //   color: "red",
      //   lastHit: 0,
      //   health: 10,
      // },
    ];
    // Particle system
    let particles = [];
    // Mark constructor
    function createMark() {
      const mark = {
        x: Math.random() * (canvas.width - 500), // Adjusted for mark's radius
        y: Math.random() * (canvas.height - 500), // Adjusted for mark's radius
        opacity: 0, // Start with opacity 0 (washed out)
        createdAt: Date.now(), // Timestamp for when the mark was created
        lifespan: 6500, // Mark will last for 2.5 seconds
        radius: 300,
        damageStyle: "mark",
        damage: 1,
        isActive: false, // Mark is not interactable until fully faded in
      };

      marks.push(mark);
    }

    // Update all marks, fade in and check for collision with player
    function updateMarks() {
      const currentTime = Date.now();

      marks = marks.filter((mark) => {
        const age = currentTime - mark.createdAt;

        // Update opacity (fade in for first 0.5 seconds)
        if (age < 5000) {
          mark.opacity = age / 5500; // Gradually increase opacity over 0.5 seconds
        } else if (age < 5500) {
          // mark.opacity = 1; // Full opacity after 0.5 seconds
          mark.color = "red";
          mark.isActive = true; // Mark is now interactable
        }
        if (age >= 6500) {
          marks = marks.filter((m) => m !== mark); // Remove the mark after collision
          return false;
        }

        // Check collision with player (same logic as handlePlayerCollisions)
        // if (
        //   mark.isActive &&
        //   isCircleColliding(
        //     { x: player.x, y: player.y, radius: player.size / 2 },
        //     mark,
        //   )
        // ) {
        //   // player.health -= 5; // Damage player by 5w
        //   // handlePlayerDamage();
        // }

        return true;
      });
    }
    function drawMarks() {
      for (let mark of marks) {
        let markRadius = 100;
        ctx.beginPath();
        // ctx.arc(mark.x, mark.y, markRadius, 0, Math.PI * 2); // Draw a circle with radius 10
        ctx.arc(mark.x, mark.y, mark.radius, 0, Math.PI * 2); // Draw a circle with radius 10

        // ctx.fillStyle = `rgba(0, 0, 0, ${mark.opacity})`; // Black color with opacity

        // Set color based on mark's age
        if (mark.color === "red") {
          ctx.fillStyle = `rgba(255, 0, 0, ${mark.opacity})`; // Red color
        } else {
          ctx.fillStyle = `rgba(0, 0, 0, ${mark.opacity})`; // Default color (black)
        }
        ctx.fill();
      }
    }

    setInterval(createMark, 3000); // Spawn a mark every 3 seconds

    let canControl = true; // Flag to allow/disallow controls
    let timeoutId; // To store the setTimeout reference for clearing the timeout if needed
    let isGameOver = false; // Flag to track if the game is over

    // Projectiles Array
    let projectiles = [];
    let meleeStrikes = [];
    let magicStrikes = [];

    // Mouse position
    let mouseX = 0;
    let mouseY = 0;

    // Character properties
    const character = {
      x: 200,
      y: 200,
      width: 50,
      height: 100,
      speed: 5,
    };

    // Player Object
    const player = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      width: 50,
      height: 100,
      size: 40,
      speed: 4,
      angle: 0, // Forward direction (in radians)
      color: "blue",
      health: 10,
      damage: 1,
      damageStyle: "projectile",
      defenseStyle: "projectile",
      lives: 3,
      lastHit: 0,
    };

    // Handle player movement
    const keys = {};
    window.addEventListener("keydown", (e) => {
      keys[e.key.toLowerCase()] = true;
    });
    window.addEventListener("keyup", (e) => {
      keys[e.key.toLowerCase()] = false;
    });

    // Handle player controls
    function updatePlayer(player) {
      if (!canControl || isGameOver) return; // Skip if the game is over or controls are disabled

      // // Calculate the angle between the player and the mouse
      // player.angle = Math.atan2(mouseY - player.y, mouseX - player.x);

      // Calculate the angle between the player and the mouse
      const angleToMouse = Math.atan2(mouseY - player.y, mouseX - player.x);
      player.angle = angleToMouse;

      // // Determine whether the player is facing forward or backward
      // player.isFacingBack = Math.abs(player.angle) > Math.PI / 2;
      // player.isFacingBack = Math.abs(player.angle) > Math.PI / 2;

      // Check if the mouse is above the player (on the Y-axis)
      player.isFacingBack = mouseY < player.y;

      // // Determine if the player should face back based on tightened bounds
      // const FRONT_ANGLE_THRESHOLD = Math.PI / 2; // Â±45 degrees (front-facing range)
      // player.isFacingBack =
      //   player.angle > FRONT_ANGLE_THRESHOLD ||
      //   player.angle < -FRONT_ANGLE_THRESHOLD;

      // Move player based on keyboard input
      //move up on the canvas
      if (keys["w"]) {
        player.y -= player.speed;
      }
      //move down on the canvas
      if (keys["s"]) {
        player.y += player.speed;
      }
      if (keys["a"]) {
        // Move left on the canvas
        player.x -= player.speed;
      }

      if (keys["d"]) {
        // Move right on the canvas
        player.x += player.speed;
      }

      // Boundaries check
      player.x = Math.max(
        player.size / 2,
        Math.min(canvas.width - player.size / 2, player.x),
      );
      player.y = Math.max(
        player.size / 2,
        Math.min(canvas.height - player.size / 2, player.y),
      );

      // Response to player pressing space bar
      if (keys[" "]) {
        // probably activate a dodge or dash on space bar
        keys[" "] = false; // Prevent continuous attacking
      }

      if (attacking) {
        switch (player.damageStyle) {
          case "projectile":
            projectileStrike();
            return;
          case "melee":
            meleeStrikes.push(meleeStrike(player));
            return;
          case "magic":
            magicStrike();
            return;
        }
      }
    }

    // Handle player collision and death
    //handles applying status debuffs, damage, to player
    function handlePlayerDamage(damageRoll) {
      if (isPlayerDead) return; // Stop further execution if the player is already dead

      //check the damage triangle
      const combatCheck = checkCombatTriangle(
        damageRoll.damageStyle,
        player.defenseStyle,
      );

      combatCheck ? (player.health = player.health - damageRoll.damage) : [];

      if (player.health <= 0) {
        isPlayerDead = true;
        canControl = false;
        player.lives--;
        createBloodSplatterEffect(player.x, player.y);

        if (player.lives <= 0) {
          // If player has no lives left, freeze the game and show the respawn button
          isGameOver = true;
        }
        // else {
        //   // Disable controls for 2 seconds after player death
        //   canControl = false;
        //   timeoutId = setTimeout(() => {
        //     canControl = true; // Re-enable controls after timeout
        //   }, 2000); // 2000ms = 2 seconds
        // }
        showRespawnButton(); // Show the respawn button

        // showRespawnButton(); // Show the respawn button
        // respawnPlayer(); // Reset player to the center of the canvas
        // Bring focus back to the canvas
        const canvas = document.querySelector("canvas");
        if (canvas) {
          canvas.focus();
        }

        // // Re-enable controls after 2 seconds
        // timeoutId = setTimeout(() => {
        //   canControl = true; // Re-enable controls after timeout
        // }, 2000); // 2000ms = 2 seconds
      }
    }

    function respawnPlayer() {
      // Reset player position to the center of the canvas
      player.x = canvas.width / 2;
      player.y = canvas.height / 2;

      // Optionally, reset player health or other properties if needed
      player.health = player.health || 10; // Assuming the player starts with 10 health
      player.lastHitTime = 0; // Reset the cooldown timer if necessary
      marks = [];
      isPlayerDead = false; // Re-enable damage handling
      canControl = true;
      // document.body.removeChild(respawnButton); // Remove the respawn button after clicking
    }

    // Create projectiles on space press
    function projectileStrike() {
      const { x, y, angle } = player;
      const size = 10;
      const speed = player.speed * 3;
      projectiles.push({
        x: x + Math.cos(angle) * (player.size / 2), // Start at the tip of the player
        y: y + Math.sin(angle) * (player.size / 2),
        angle,
        size,
        speed,
      });
    }

    // Update function to move the melee strike
    // function updateMeleeStrikes() {
    //   for (let i = 0; i < meleeStrikes.length; i++) {
    //     const attack = meleeStrikes[i];
    //     console.log({ attack });
    //     // Move the attack forward
    //     attack.x += Math.cos(attack.angle) * attack.speed;
    //     attack.y += Math.sin(attack.angle) * attack.speed;
    //     attack.distanceTraveled += attack.speed;

    //     // Remove attack if it has exceeded its max distance
    //     if (attack.distanceTraveled >= attack.maxDistance) {
    //       meleeStrikes.splice(i, 1);
    //       i--; // Adjust index to avoid skipping elements
    //     }
    //   }
    // }

    // Magic Strike: Delay before activation at clicked location
    function magicStrike(event) {
      if (!event) return;
      const size = 50; // Size of the magic effect
      const activationDelay = 500; // Delay before activation (in ms)

      // Get mouse position where the user clicked
      const canvas = document.querySelector("canvas");
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;

      // Create a magic strike with delay
      magicStrikes.push({
        x,
        y,
        size,
        active: false, // Initially inactive
        activationTime: Date.now() + activationDelay,
      });
    }

    // Update function to activate magic strikes after delay
    function updateMagicStrikes() {
      const currentTime = Date.now();
      for (let i = 0; i < magicStrikes.length; i++) {
        const strike = magicStrikes[i];

        // Check if the delay has passed and activate the strike
        if (currentTime >= strike.activationTime && !strike.active) {
          strike.active = true; // Activate the strike after delay
          // Optionally: Add a visual effect for the magic strike
        }

        // Optionally: Remove magic strike after a certain time or effect
        // (For example, remove after it lasts for 3 seconds)
        if (strike.active && currentTime - strike.activationTime > 3000) {
          magicStrikes.splice(i, 1);
          i--;
        }
      }
    }

    // Variable to track the currently selected weapon
    let activeWeapon = player.damageStyle;

    // Function to handle cycling between weapons
    function cycleWeapon() {
      if (player.damageStyle === "projectile") {
        player.damageStyle = "melee"; // Cycle to melee
        weaponBox.textContent = player.damageStyle;
        weaponBox.classList.remove("green");
        weaponBox.classList.add("red");
      } else if (player.damageStyle === "melee") {
        player.damageStyle = "magic"; // Cycle to magic
        weaponBox.textContent = player.damageStyle;
        weaponBox.classList.remove("red");
        weaponBox.classList.add("blue");
      } else if (player.damageStyle === "magic") {
        player.damageStyle = "projectile"; // Cycle back to projectile
        weaponBox.textContent = player.damageStyle;
        weaponBox.classList.remove("blue");
        weaponBox.classList.add("green");
      }
      console.log(`Current Weapon: ${player.damageStyle}`); // Log the current weapon for debugging
    }

    //1. This stuff here only works for projectileStrike because its the only attack method properly implemented
    // Function to handle attack based on the active weapon
    // function handleAttack(event) {
    //   if (player.damageStyle === "projectile") {
    //     if (event.code === "Space") {
    //       projectileStrike(); // Fire projectile attack
    //     }
    //   } else if (player.damageStyle === "melee") {
    //     if (event.code === "Space") {
    //       meleeStrike(); // Perform melee strike when Space is pressed
    //     }
    //   } else if (player.damageStyle === "magic") {
    //     if (event.type === "click") {
    //       magicStrike(event); // Perform magic strike on click
    //     }
    //   }
    // }

    // Add event listener for "X" key to cycle weapons
    document.addEventListener("keydown", (event) => {
      if (event.code === "KeyX") {
        cycleWeapon(); // Cycle to the next weapon on pressing "X"
      }
    });

    // Add event listener for attacking based on the active weapon
    // document.addEventListener("keydown", (event) => {
    //   handleAttack(event);
    // });

    // Add mouse event listener for magic strike (which requires a click)
    // document.querySelector("canvas").addEventListener("click", (event) => {
    //   handleAttack(event); // Perform magic strike when canvas is clicked
    // });

    // Update projectiles
    function updateProjectiles() {
      projectiles = projectiles.filter(
        (p) => p.x > 0 && p.x < canvas.width && p.y > 0 && p.y < canvas.height, // Remove off-screen projectiles
      );

      for (let p of projectiles) {
        p.x += Math.cos(p.angle) * p.speed;
        p.y += Math.sin(p.angle) * p.speed;
      }
    }

    // Draw projectiles
    function drawProjectiles() {
      for (let p of projectiles) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fillStyle = "red";
        ctx.fill();
        ctx.closePath();
      }
    }

    // Update melee strikesx
    // function updateMeleeStrikes() {
    //   meleeStrikes = meleeStrikes.filter((m) => {
    //     // Remove melee strikes that have traveled beyond their maximum range
    //     const distanceTravelled = Math.sqrt(
    //       Math.pow(m.xEnd - m.xStart, 2) + Math.pow(m.yEnd - m.yStart, 2),
    //     );
    //     return distanceTravelled < 400; // 100 is the max range for the melee strike (can be adjusted)
    //   });

    //   for (let m of meleeStrikes) {
    //     // Move the melee strike forward (in this case, this is a simple linear direction)
    //     const range = 400; // Define the max range for the melee strike
    //     const deltaX = Math.cos(m.angle) * m.speed;
    //     const deltaY = Math.sin(m.angle) * m.speed;

    //     m.xStart += deltaX;
    //     m.yStart += deltaY;
    //     m.xEnd = m.xStart + Math.cos(m.angle) * range;
    //     m.yEnd = m.yStart + Math.sin(m.angle) * range;
    //   }
    // }

    //=================================================================================================================
    // Update melee strikes
    // function updateMeleeStrikes() {
    //   if (meleeStrikes.length) {
    //     // console.log({meleeStrikes});
    //   }
    //   meleeStrikes = meleeStrikes.filter((m) => {
    //     // Calculate the distance traveled based on start and current position
    //     const distanceTravelled = Math.sqrt(
    //       Math.pow(m.xStart - player.x, 2) + Math.pow(m.yStart - player.y, 2),
    //     );
    //     // return distanceTravelled < 400; // Remove melee strikes if it exceeds max range (400 units)
    //     return m.attackTiming > 400; // Remove melee strikes if it exceeds max range (400 units)
    //   });

    //   // Update position and range of each melee strike
    //   for (let m of meleeStrikes) {
    //     const deltaX = Math.cos(m.angle) * m.speed;
    //     const deltaY = Math.sin(m.angle) * m.speed;
    //     // console.log(`is something wrong with ${deltaX}`);
    //     // Update the strike's starting position
    //     // m.xStart += deltaX;
    //     // m.yStart += deltaY;

    //     // Calculate the new endpoint of the melee strike
    //     m.xEnd = m.xStart + Math.cos(m.angle) * 200; // Max range
    //     m.yEnd = m.yStart + Math.sin(m.angle) * 200;
    //   }
    // }

    //===========================================================================================
    function updateMeleeStrikes() {
      meleeStrikes = meleeStrikes.filter((m) => {
        // Remove melee strikes after some time/distance
        return Date.now() - m.attackTiming < 400; // Lifetime of melee strike (400ms)
      });

      for (let m of meleeStrikes) {
        m.xEnd = m.xStart + Math.cos(m.angle) * 200; // Max range for line
        m.yEnd = m.yStart + Math.sin(m.angle) * 200;

        // Check collision with balls
        for (let ball of balls) {
          const distance = distanceToSegment(
            ball.x,
            ball.y,
            m.xStart,
            m.yStart,
            m.xEnd,
            m.yEnd,
          );

          const combatTimer = Date.now() - ball.lastHit > 500; //verifies that damage is dealt in 800ms blocks
          console.log({ combatTimer });
          // If distance is less than the ball's radius, deal damage
          if (distance < ball.radius && combatTimer) {
            ball.lastHit = Date.now();

            console.log("Ball hit by melee strike!");

            // Handle damage to ball or other game logic

            createParticles(ball.x, ball.y); // Create particles at collision point
            ball.health -= 1; // Example: reduce ball's health

            if (ball.health <= 0) {
              balls = balls.filter((b) => b !== ball); // Remove ball if health <= 0
            }
          }
        }
      }
    }

    function distanceToSegment(px, py, x1, y1, x2, y2) {
      const l2 = (x2 - x1) ** 2 + (y2 - y1) ** 2; // Square of the segment length

      if (l2 === 0) return Math.hypot(px - x1, py - y1); // Line is a point

      // Projection factor 't' onto the line segment
      let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2;
      t = Math.max(0, Math.min(1, t)); // Clamp t to [0, 1] to stay within the segment

      // Closest point on the line segment
      const closestX = x1 + t * (x2 - x1);
      const closestY = y1 + t * (y2 - y1);

      // Distance from the point to the closest point on the segment
      return Math.hypot(px - closestX, py - closestY);
    }

    // Draw melee strikes
    function drawMeleeStrikes() {
      ctx.strokeStyle = "blue"; // Color of the melee strike
      ctx.lineWidth = 5; // Set line width for better visibility
      for (let m of meleeStrikes) {
        ctx.beginPath();
        ctx.moveTo(m.xStart, m.yStart);
        ctx.lineTo(m.xEnd, m.yEnd); // Draw a line to the end point of the melee strike
        ctx.stroke();
        ctx.closePath();
      }
    }

    //=================================================================================================================

    // Listen for mouse movement to track the mouse position
    canvas.addEventListener("mousemove", (event) => {
      mouseX = event.clientX - canvas.offsetLeft; // Adjust for canvas position
      mouseY = event.clientY - canvas.offsetTop; // Adjust for canvas position
    });

    /*
     *
     * the beginning of handling player attacks
     */
    let attacking = false; // Track if the player is attacking

    // Listen for left mouse button click (mousedown event)
    canvas.addEventListener("mousedown", (event) => {
      if (event.button === 0) {
        // Left mouse button clicked
        attacking = true;
      }
    });

    // Listen for mouse up event to stop attacking (optional)
    canvas.addEventListener("mouseup", (event) => {
      if (event.button === 0) {
        // Left mouse button released
        attacking = false;
      }
    });

    function drawPlayer(ctx, character) {
      ctx.save();
      // Translate to the character's position
      ctx.translate(character.x, character.y);

      console.log(character.angle);
      ctx.rotate(character.angle);

      if (character.angle < 3.14 && character.angle > 1.7) {
        // Rotate player based on the angle (no added Math.PI)
        // ctx.rotate(2 *character.angle);
         ctx.scale(1, -1); // Flip horizontally
      } 
       if (character.angle > -3.14 && character.angle < -1.97) {
        // ctx.scale(1, -1); // Flip horizontally
        // ctx.rotate(-character.angle);
      } 
      if (character.angle >= -1.7 && character.angle < -0.01) {
        ctx.scale(1, -1); // Flip horizontally
        // ctx.rotate(-character.angle);
      } 
      // else {
      //   ctx.rotate(character.angle);
      //   // ctx.scale(1, -1); // Flip horizontally
      // }

      // Apply horizontal flip for back-facing orientation
      // if (character.isFacingBack) {
      //   ctx.scale(1, -1); // Flip horizontally
      // }sadss

      // Set color based on mouse position

      // // Flip horizontally when showing the back
      if (player.isFacingBack) {
        ctx.scale(1, -1); // Mirror vertically to represent the back
        // } else {
      }

      // ctx.rotate(character.angle);
      let fillColor = player.color;
      // Change the fill style if recently hit
      if (Date.now() - character.lastHitTime < 1500) {
        ctx.fillStyle = "rgba(255, 0, 0, 0.5)"; // Semi-transparent red during cooldown
      } else if (character.isFacingBack) {
        fillColor = "black";
        ctx.fillStyle = fillColor; // Turn black when the mouse is above
      } else {
        ctx.fillStyle = character.color;
      }

      // Draw the head (circle)
      ctx.beginPath();
      // ctx.arc(0, -character.height / 2, 15, 0, Math.PI * 2); // Centered around transformed origin
      ctx.arc(0, 0, 15, 0, Math.PI * 2); // Draw the head at the origin (the new translated point)

      ctx.fillStyle = fillColor; // Apply color
      ctx.fill();
      ctx.stroke();

      // Draw the body (line)
      ctx.beginPath();
      // ctx.moveTo(0, -character.height / 2 + 15); // Start just below the head
      // ctx.lineTo(0, character.height / 2 - 20); // Extend to the bottom of the body
      ctx.moveTo(0, 15); // Start just below the head
      ctx.lineTo(0, character.height / 2 - 20); // Extend to the bottom of the body
      ctx.strokeStyle = fillColor; // Apply color
      ctx.lineWidth = 3;
      ctx.stroke();

      // Draw the arms (lines)
      if (player.health >= 10) {
        ctx.beginPath();
        // ctx.moveTo(0, -character.height / 4); // Shoulder height
        // ctx.lineTo(-character.width / 2, -character.height / 8); // Left arm
        // ctx.moveTo(0, -character.height / 4);
        // ctx.lineTo(character.width / 2, -character.height / 8); // Right arm
        ctx.moveTo(0, 15); // Shoulder height
        ctx.lineTo(-character.width / 2, -character.height / 8); // Left arm
        ctx.moveTo(0, 15);
        ctx.lineTo(character.width / 2, -character.height / 8); // Right arm
        ctx.strokeStyle = fillColor; // Apply color
        ctx.stroke();
      } else if (player.health < 7) {
        ctx.beginPath();
        // ctx.moveTo(0, -character.height / 4); // Shoulder height
        // ctx.lineTo(-character.width / 2, -character.height / 8); // Left arm
        ctx.moveTo(0, 15); // Shoulder height
        ctx.lineTo(-character.width / 2, -character.height / 8); // Left arm
        ctx.strokeStyle = fillColor; // Apply color
        ctx.stroke();
      }

      // Draw the legs (lines)
      ctx.beginPath();
      // ctx.moveTo(0, character.height / 2 - 20); // Base of the body
      // ctx.lineTo(-character.width / 4, character.height / 2); // Left leg
      // ctx.moveTo(0, character.height / 2 - 20);
      // ctx.lineTo(character.width / 4, character.height / 2); // Right leg
      ctx.moveTo(0, character.height / 2 - 20); // Base of the body
      ctx.lineTo(-character.width / 4, character.height / 2); // Left leg
      ctx.moveTo(0, character.height / 2 - 20);
      ctx.lineTo(character.width / 4, character.height / 2); // Right leg
      ctx.strokeStyle = fillColor; // Apply color
      ctx.stroke();

      if(!player.isFacingBack){// Front/Back Features
      // Front View: Draw eyes and mouth
      ctx.fillStyle = "red";
      const eyeOffset = player.size / 8 ;
      const eyeRadius = player.size / 12;

      // Eyes
      ctx.beginPath();
      ctx.arc(
        -eyeOffset,
        -player.size / 2 - player.size / 4 + 25,
        eyeRadius,
        0,
        Math.PI * 2,
      ); // Left eye
      ctx.arc(
        eyeOffset,
        -player.size / 2 - player.size / 4 + 25,
        eyeRadius,
        0,
        Math.PI * 2,
      ); // Right eye
      ctx.fill();

      // Mouth
      ctx.beginPath();
      ctx.arc(0, -player.size / 2 - player.size / 6 + 30, eyeRadius, 0, Math.PI); // Simple smile
      ctx.strokeStyle = "red"
      ctx.stroke();}

      ctx.restore();
    }

    // Draw player
    // function drawPlayer() {
    //   ctx.save();
    //   ctx.translate(player.x, player.y);
    //   ctx.rotate(player.angle);

    //   if (Date.now() - player.lastHitTime < 1500) {
    //     ctx.fillStyle = "rgba(255, 0, 0, 0.5)"; // Semi-transparent red during cooldown
    //   } else {
    //     ctx.fillStyle = player.color;
    //   }
    //   // Draw the square
    //   // ctx.fillStyle = player.color;
    //   ctx.fillRect(
    //     -player.size / 2,
    //     -player.size / 2,
    //     player.size,
    //     player.size,
    //   );

    //   // Draw forward marker
    //   ctx.beginPath();
    //   ctx.moveTo(0, -player.size / 2); // Forward point
    //   ctx.lineTo(0, player.size / 2); // Back line
    //   ctx.strokeStyle = "white";
    //   ctx.lineWidth = 2;
    //   ctx.stroke();
    //   ctx.restore();
    // }

    function getRandomNumber(min, max) {
      return Math.random() * (max - min) + min;
    }
    function assignOffenseStyle(color) {
      switch (color) {
        case "green":
          return "projectile";
        case "blue":
          return "melee";
        case "red":
          return "magic";
      }
    }
    function assignDefenseStyle(color) {
      switch (color) {
        case "green":
          return "magic";
        case "blue":
          return "projectile";
        case "red":
          return "melee";
      }
    }

    function assignColor() {
      const roll = Math.floor(getRandomNumber(0, 3));
      switch (roll) {
        case 0:
          return "green";
        case 1:
          return "blue";
        case 2:
          return "red";
      }
    }
    function canvasReset() {
      respawnPlayer();
      projectiles = [];
      balls = [];
      currentLevel++;
      marks = [];
    }
    let numEnemies;
    function levelGenerator(currentLevel) {
      const difficulty = Math.ceil(currentLevel * 1.05 + currentLevel / 2);
      numEnemies = 0.5 * currentLevel * 3;
      for (let i = 0; i < numEnemies; i++) {
        const color = assignColor();
        const damageStyle = assignOffenseStyle(color);
        const damage = 1 + difficulty;
        const defense = assignDefenseStyle(color);
        balls.push({
          x: getRandomNumber(0, canvas.width),
          y: getRandomNumber(0, canvas.width),
          radius: 20,
          vx: getRandomNumber(-5, 5),
          vy: getRandomNumber(-5, 5),
          color,
          damage,
          damageStyle,
          defense,
          lastHit: 0,
          maxHealth: 2.5 * player.health * difficulty,
          health: 2.5 * player.health * difficulty,
        });
      }
    }

    levelGenerator(currentLevel);

    function createParticles(x, y, count = 50) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x,
          y,
          vx: Math.random() * 4 - 2, // Random horizontal speed
          vy: Math.random() * 4 - 2, // Random vertical speed
          life: 100, // Particle lifespan
          lifetime: Math.random() * 20 + 10, // Random lifespan between 10 and 30 frames
          decayRate: 0.05, // Rate at which the particle fades,
          color: "rgba(255, 165, 0, 1dw)",
        });
      }
    }

    // Blood splatter particle object
    function createBloodSplatter(x, y) {
      const bloodParticle = {
        x: x,
        y: y,
        vx: (Math.random() - 0.5) * 4, // Random X velocity
        vy: (Math.random() - 0.5) * 4, // Random Y velocity
        radius: Math.random() * 5 + 2, // Random radius between 2 and 7
        color: `rgba(255, 0, 0, ${Math.random() * 0.8 + 0.2})`, // Random red with alpha
        lifetime: Math.random() * 20 + 10, // Random lifespan between 10 and 30 frames
        decayRate: 0.05, // Rate at which the particle fades
      };

      return bloodParticle;
    }

    // Update blood particles (move, fade, and remove them when they're done)
    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];

        // Move the particle
        particle.x += particle.vx;
        particle.y += particle.vy;

        // Decay the particle (shrink size and reduce opacity)
        particle.lifetime -= particle.decayRate;

        // Remove particle if lifetime is over
        if (particle.lifetime <= 0) {
          particles.splice(i, 1); // Remove the particle from the array
        }
      }
    }

    // Draw particles
    function drawParticles() {
      for (let p of particles) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 2, 0, Math.PI * 4);
        ctx.fillStyle = `rgba(255, 165, 0, ${p.life / 100})`; // Fade out
        ctx.fill();
        ctx.closePath();
      }
    }

    // Draw blood splatter particles
    function drawBloodParticles() {
      for (let particle of particles) {
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
        ctx.fillStyle = particle.color;
        ctx.fill();
        ctx.closePath();
      }
    }

    // Detect collision between two circles
    function isCircleColliding(circle1, circle2) {
      const dx = circle1.x - circle2.x;
      const dy = circle1.y - circle2.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      return distance < circle1.radius + circle2.radius; //makes sense that this would work..
    }

    // Detect collision between two circles
    function isProjectileColliding(circle1, circle2) {
      const dx = circle1.x - circle2.x;
      const dy = circle1.y - circle2.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      return distance <= circle1.radius + circle2.radius;
    }

    // Handle collisions between balls
    function handleBallBallCollisions() {
      for (let i = 0; i < balls.length; i++) {
        for (let j = i + 1; j < balls.length; j++) {
          if (isCircleColliding(balls[i], balls[j])) {
            // Reverse velocities for simple collision response
            const tempVx = balls[i].vx;
            const tempVy = balls[i].vy;
            balls[i].vx = balls[j].vx;
            balls[i].vy = balls[j].vy;
            balls[j].vx = tempVx;
            balls[j].vy = tempVy;
          }
        }
      }
    }

    // // Handle collisions with player
    //handles players being hit with attacks,
    //draining players health
    //inflicting status affects on player
    //
    function handlePlayerCollisions() {
      const currentTime = Date.now();
      const playerRadius = Math.sqrt(
        (player.size / 2) ** 2 + (player.size / 2) ** 2,
      );

      for (let ball of balls) {
        const combatTimer = Date.now() - player.lastHit > 1200; //verifies that damage is dealt in 800ms blocks

        //convert the radius that was calculated in order to calculate collision of radius's
        if (
          combatTimer &&
          isCircleColliding(
            { x: player.x, y: player.y, radius: playerRadius },
            ball,
          )
        ) {
          // Check for cooldown
          // if (!ball.lastHit || currentTime - ball.lastHit > 1500) {
          const damageRoll = {
            damage: ball.damage,
            damageStyle: ball.damageStyle,
            // };
          };
          handlePlayerDamage(damageRoll);
          createParticles(ball.x, ball.y); // Create particles at collision point
          ball.lastHit = currentTime; // Set cooldown timestamp

          //1. check that player combat style is melee
          //apply 1.25x normal damage if ball is weak to melee
          //apply apply 1x damage if ball is normal to melee
          //apply 1 damage if ball is strong against melee

          //not doing damage here
          // ball.health -= 2; // Reduce ball health by 2

          // Update the player's last hit time to initiate the invincibility period
          player.lastHitTime = currentTime;

          if (player.health <= 0) {
            createBloodSplatterEffect(player.x, player.y);
            player.health = 0;
            // respawnPlayer(); // Reset player to the center of the canvas
          }

          if (ball.health <= 0) {
            ball.health = 0;
            handleBallDestruction(ball); // Handle ball destruction (optional)
          }
        }
      }
      for (let mark of marks) {
        const combatTimer = Date.now() - player.lastHit > 800; //verifies that damage is dealt in 800ms blocks
        if (
          mark.isActive &&
          combatTimer &&
          isCircleColliding(
            { x: player.x, y: player.y, radius: playerRadius },
            mark,
          )
        ) {
          const damageRoll = {
            damage: mark.damage,
            damageStyle: mark.damageStyle,
          };
          handlePlayerDamage(damageRoll);
          createParticles(mark.x, mark.y);
        }
      }
    }

    // Create multiple blood splatter particles
    function createBloodSplatterEffect(x, y) {
      for (let i = 0; i < 20; i++) {
        // Create 20 particles
        particles.push(createBloodSplatter(x, y)); // Add the particle to the particles array
      }
    }

    // Check for collision between two balls
    function isColliding(ball1, ball2) {
      let dx = ball1.x - ball2.x;
      let dy = ball1.y - ball2.y;
      let distance = Math.sqrt(dx * dx + dy * dy);
      return distance < ball1.radius + ball2.radius;
    }

    // Update ball positions and handle collisions
    function updateBalls() {
      for (let i = 0; i < balls.length; i++) {
        let ball = balls[i];

        // Update position
        ball.x += ball.vx;
        ball.y += ball.vy;

        // Bounce off walls
        if (ball.x - ball.radius < 0 || ball.x + ball.radius > canvas.width) {
          ball.vx *= -1;
        }
        if (ball.y - ball.radius < 0 || ball.y + ball.radius > canvas.height) {
          ball.vy *= -1;
        }

        // Check for collisions with other balls
        for (let j = i + 1; j < balls.length; j++) {
          let otherBall = balls[j];
          if (isColliding(ball, otherBall)) {
            // Simple velocity reversal on collision
            ball.vx *= -1;
            ball.vy *= -1;
            otherBall.vx *= -1;
            otherBall.vy *= -1;

            // Create particles at collision point
            createParticles(
              (ball.x + otherBall.x) / 2,
              (ball.y + otherBall.y) / 2,
            );
          }
        }
      }
    }

    // Draw balls
    function drawBalls() {
      for (let ball of balls) {
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        ctx.fillStyle = ball.color;
        ctx.fill();
        ctx.closePath();

        // Draw health bar above the ball
        const healthBarWidth = ball.radius * 2 + ball.radius / 2; // Width of the health bar
        const healthBarHeight = 10; // Height of the health bar
        const healthBarX = ball.x - healthBarWidth / 2; // Position horizontally centered on the ball
        const healthBarY = ball.y - ball.radius - 12; // Position the health bar above the ball

        // const healthBarFill = (ball.health / 100) * healthBarWidth; // Proportional fill based on health
        const healthBarFill = (ball.health / ball.maxHealth) * healthBarWidth; // Proportional fill based on health

        // Draw the background of the health bar (empty bar)
        ctx.fillStyle = "#000"; // Black background for the health bar
        ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

        // Draw the filled portion of the health bar (green for health)
        ctx.fillStyle = "red";
        ctx.fillRect(healthBarX, healthBarY, healthBarFill, healthBarHeight);
      }
    }

    // Draw health
    function drawHealth() {
      ctx.fillStyle = "black";
      ctx.font = "20px Arial";
      ctx.fillText(
        `Health: ${player.health} \n Lives: ${player.lives}`,
        10,
        30,
      );
    }

    function checkCombatTriangle(damageStyle, defenseStyle) {
      return damageStyle !== defenseStyle;
    }

    function toggleDamageStyleErrorMessage() {
      const errorMessageDiv = document.getElementById("errorMessage");
      const currentTime = Date.now(); // Get the current time in milliseconds

      // If the error message is not currently showing OR 3 seconds have passed since last shown
      if (!showError && currentTime - lastErrorTime >= 1000) {
        showError = true;
        lastErrorTime = currentTime; // Update the last error time
        errorMessageDiv.textContent =
          "Target defence blocked your attack! Invalid attack used!";
        errorMessageDiv.classList.remove("hidden");
        errorMessageDiv.classList.add("visible");

        // Hide the error message after 2 seconds
        setTimeout(() => {
          showError = false;
          errorMessageDiv.classList.remove("visible");
          errorMessageDiv.classList.add("hidden");
        }, 2000);
      }
    }

    // Handle player projectile collision with balls
    function handleProjectileCollisions() {
      for (let i = 0; i < projectiles.length; i++) {
        const currentProjectile = projectiles[i];

        //calculate radius of the non circle object
        const projectileRadius = Math.sqrt(
          (currentProjectile.size / 2) ** 2 + (currentProjectile.size / 2) ** 2,
        );

        // for (let projectile of projectiles) {
        for (let ball of balls) {
          //convert the radius that was calculated in order to calculate collision of radius's
          if (
            isProjectileColliding(
              {
                x: currentProjectile.x,
                y: currentProjectile.y,
                radius: projectileRadius,
              },
              ball,
            )
          ) {
            if (checkCombatTriangle(player.damageStyle, ball.defense)) {
              console.log(
                `The attack style was "projectile" and the defence style was ${ball.defense}`,
              );
              ball.health -= 2; // Reduce ball health by 2 on projectile hit
            } else {
              toggleDamageStyleErrorMessage();
            }

            createParticles(ball.x, ball.y); // Create particles at the collision point
            removeProjectile(projectiles[i]); // Remove the projectile after collision
            if (ball.health <= 0) {
              ball.health = 0;
              handleBallDestruction(ball); // Handle ball destruction (optional)
            }
          }
        }
      }
    }

    // Handle player projectile collision with balls
    function handleMeleeCollisions() {
      for (let i = 0; i < meleeStrikes.length; i++) {
        const currentMelee = meleeStrikes[i];

        //calculate radius of the non circle object
        const meleeRadius = Math.sqrt(
          (currentMelee.size / 2) ** 2 + (currentMelee.size / 2) ** 2,
        );

        // for (let projectile of projectiles) {
        for (let ball of balls) {
          //convert the radius that was calculated in order to calculate collision of radius's
          if (
            isProjectileColliding(
              {
                x: currentMelee.x,
                y: currentMelee.y,
                radius: meleeRadius,
              },
              ball,
            )
          ) {
            if (checkCombatTriangle(player.damageStyle, ball.defense)) {
              console.log(
                `The attack style was "projectile" and the defence style was ${ball.defense}`,
              );
              ball.health -= 2; // Reduce ball health by 2 on projectile hit
            } else {
              toggleDamageStyleErrorMessage();
            }

            createParticles(ball.x, ball.y); // Create particles at the collision point
            removeProjectile(projectiles[i]); // Remove the projectile after collision
            if (ball.health <= 0) {
              ball.health = 0;
              handleBallDestruction(ball); // Handle ball destruction (optional)
            }
          }
        }
      }
    }

    // Function to remove a projectile from the projectiles array
    function removeProjectile(index) {
      // Remove the projectile at the specified index
      projectiles.splice(index, 1);
    }

    // Optional: Handle ball destruction (e.g., remove the ball when its health reaches 0)
    function handleBallDestruction(ball) {
      const index = balls.indexOf(ball);
      if (index > -1) {
        balls.splice(index, 1); // Remove ball from array
      }
    }

    // Show respawn button
    function showRespawnButton() {
      const existingButton = document.querySelector("button.respawn-button");
      let respawnButton;

      if (existingButton) {
        document.body.removeChild(existingButton);
      } else {
        respawnButton = document.createElement("button");
      }
      // const respawnButton = document.createElement("button");
      respawnButton.innerText = player.lives > 0 ? "Respawn" : "Game Over";
      respawnButton.style.position = "absolute";
      respawnButton.style.top = "50%";
      respawnButton.style.left = "50%";
      respawnButton.style.transform = "translate(-50%, -50%)";
      respawnButton.style.padding = "10px 20px";
      respawnButton.style.fontSize = "20px";
      document.body.appendChild(respawnButton);

      respawnButton.addEventListener("click", () => {
        if (player.lives <= 0) {
          respawnGame();
        } else {
          respawnPlayer();
        }
      });

      // Attach the event listener
      const onClick = () => {
        // Remove the button from the DOM
        if (respawnButton.parentNode) {
          respawnButton.removeEventListener("click", onClick); // Cleanup listener
          document.body.removeChild(respawnButton);
        } else {
          console.warn("Respawn button was already removed or doesn't exist");
        }

        // // Reset the game state
        // if (player.lives <= 0) {
        //   respawnGame();
        // } else {
        //   respawnPlayer();
        // }
      };

      // Add click event listener
      respawnButton.addEventListener("click", onClick);

      // Add click event listener
      respawnButton.addEventListener("click", onClick);
    }

    // Reset the game with 3 lives
    function respawnGame() {
      particles = [];
      marks = [];

      player.lives = 3; // Reset player lives
      player.health = 100; // Reset player health
      isGameOver = false; // Reset game over flag
      canControl = true;
      isPlayerDead = false; // Allow damage handling again
      respawnPlayer(); // Reset player position
      window.location.reload(); // Reload the page to reset the game

      // Optionally reset any other game states here
    }

    weaponBox.textContent = player.damageStyle;
    // Main game loop
    function loop() {
      if (!isGameOver) {
        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas

        //update game objects
        updatePlayer(player);
        updateBalls();
        updateMarks();
        updateParticles();
        updateProjectiles();
        updateMeleeStrikes();
        updateMagicStrikes();
        handleBallBallCollisions();
        handlePlayerCollisions();
        handleProjectileCollisions();
        //draw game objects

        // drawCharacter(ctx, character); // Draw the character
        drawPlayer(ctx, player); // Draw the character
        // drawPlayer();
        drawBalls();
        drawHealth();
        drawProjectiles();
        drawMeleeStrikes();
        drawParticles();
        drawBloodParticles();

        drawMarks();
      }
      requestAnimationFrame(loop);
    }

    loop();
  </script>
</html>
