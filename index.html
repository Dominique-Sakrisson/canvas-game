<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>canvas game</title>
    <link rel="stylesheet" href="index.css" />
  </head>
  <body>
    <div id="container">
      <canvas id="gameCanvas" width="1000" height="1000"></canvas>
      <div id="errorMessage" class="hidden">Invalid attack used!</div>
      <div id="weapon" class="weaponBox"></div>
    </div>
  </body>
  <script type="module">
    import { meleeStrike } from "./character_attacks.js";
    const canvas = document.getElementById("gameCanvas");
    const weaponBox = document.getElementById("weapon");
    weaponBox.classList.add("green");
    const ctx = canvas.getContext("2d");
    let currentLevel = 1;

    let showError = false; // Boolean value to toggle the error message
    let lastErrorTime = 0; // Tracks the last time the error message was triggered
    let isPlayerDead = false; // Flag to prevent multiple executions when health drops to 0

    let marks = []; // Array to store marks
    // Ball objects
    let balls = [];
    // Particle system
    let particles = [];
    // Mark constructor
    function createMark() {
      const mark = {
        x: Math.random() * (canvas.width - 150), // Adjusted for mark's radius
        y: Math.random() * (canvas.height - 150), // Adjusted for mark's radius
        opacity: 1, // Start with opacity 0 (washed out)
        createdAt: Date.now(), // Timestamp for when the mark was created
        lifespan: 6500, // Mark will last for 2.5 seconds
        radius: getRandomInt(25, 300),
        damageStyle: "mark",
        damage: 1,
        // baseColor: getRandomColor(), // Store base color
        isActive: false, // Mark is not interactable until fully faded in
      };
      mark.damage = mark.radius * 0.01;

      // Initially set the color to the base color with 0 opacity
      // mark.color = `rgba(${mark.baseColor.r}, ${mark.baseColor.g}, ${mark.baseColor.b}, ${mark.opacity})`;
      marks.push(mark);
    }

    // // Update all marks, fade in and check for collision with player
    function updateMarks() {
      const currentTime = Date.now();

      marks = marks.filter((mark) => {
        const age = currentTime - mark.createdAt;

        // Gradually fade in the gradient over the entire lifespan
        const gradientOpacity = Math.min(age / mark.lifespan, 1); // Fade in from 0 to 1 over the lifespan

        // Create a radial gradient with increasing opacity
        const gradient = ctx.createRadialGradient(
          mark.x,
          mark.y,
          0, // Start at the center of the mark
          mark.x,
          mark.y,
          mark.radius, // End at the outer edge of the mark
        );

        // Apply the gradient opacity
        gradient.addColorStop(0, `rgba(255, 0, 0, ${gradientOpacity})`); // Red at the center
        gradient.addColorStop(
          0.5,
          `rgba(255, 165, 0, ${gradientOpacity * 0.7})`,
        ); // Orange in the middle
        gradient.addColorStop(1, `rgba(0, 0, 255, ${gradientOpacity * 0.4})`); // Blue at the outer edge

        mark.color = gradient;

        // Once the gradient reaches 80%, start the flashing effect for the borders
        if (gradientOpacity >= 0.65 && !mark.hasFlashed) {
          mark.isActive = true;
          mark.hasFlashed = true;
          mark.flashCount = 5; // Set the number of flashes to 5
          mark.flashInterval = setInterval(() => {
            if (mark.flashCount > 0) {
              // Toggle the border color to simulate the flash effect
              mark.borderColor =
                mark.borderColor === "white" ? "transparent" : "white";
              mark.flashCount--;
            } else {
              clearInterval(mark.flashInterval); // Stop flashing after 5 flashes
              mark.borderColor = "transparent"; // Reset the border color after flashing
            }
          }, 200); // Flash every 200ms
        }

        // Draw the mark with the current gradient and border color
        ctx.save(); // Save the current context to prevent affecting other objects

        // Draw the filled mark
        ctx.beginPath();
        ctx.arc(mark.x, mark.y, mark.radius, 0, Math.PI * 2);
        ctx.fillStyle = mark.color;
        ctx.fill();

        // Apply border only if it's flashing
        if (mark.borderColor) {
          ctx.lineWidth = 20; // Apply thicker border when flashing
          ctx.strokeStyle = mark.borderColor; // Apply the flashing border color
          ctx.stroke(); // Apply the stroke
        } else {
          ctx.lineWidth = 0; // Avoid any border if not flashing
        }

        ctx.restore(); // Restore the context to avoid affecting other drawings

        // Mark is now interactable after it has fully faded in
        if (gradientOpacity === 1) {
          mark.isActive = true;
        }

        // Remove the mark after it exceeds its lifespan
        if (age >= mark.lifespan) {
          marks = marks.filter((m) => m !== mark); // Remove the mark after collision
          return false;
        }

        return true;
      });
    }
    function getRandomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    let randomInt = getRandomInt(1, 10);
    function drawMarks() {
      for (let mark of marks) {
        let markRadius = getRandomInt(25, 100);
        ctx.beginPath();
        // ctx.arc(mark.x, mark.y, markRadius, 0, Math.PI * 2); // Draw a circle with radius 10
        ctx.arc(mark.x, mark.y, mark.radius, 0, Math.PI * 2); // Draw a circle with radius 10

        // ctx.fillStyle = `rgba(0, 0, 0, ${mark.opacity})`; // Black color with opacity
        ctx.fillStyle = mark.color;

        // Set color based on mark's age
        // if (typeof mark.color === "object") {
        //   // ctx.fillStyle = `rgba(255, 0, 0, ${mark.opacity})`; // Red color
        //   ctx.fillStyle = mark.color;
        // } else {
        //   ctx.fillStyle = `rgba(0, 0, 0, ${mark.opacity})`; // Default color (black)
        // }
        ctx.fill();
      }
    }

    setInterval(createMark, 1500); // Spawn a mark every 3 seconds

    let canControl = true; // Flag to allow/disallow controls
    let timeoutId; // To store the setTimeout reference for clearing the timeout if needed
    let isGameOver = false; // Flag to track if the game is over

    // Projectiles Array
    let projectiles = [];
    let meleeStrikes = [];
    let magicStrikes = [];

    // Mouse position
    let mouseX = 0;
    let mouseY = 0;

    // Character properties
    const character = {
      x: 200,
      y: 200,
      width: 50,
      height: 100,
      speed: 5,
    };

    // Player Object
    const player = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      width: 50,
      height: 100,
      size: 40,
      speed: 4,
      currentSpeed: 4,
      isSlowed: false,
      angle: 0, // Forward direction (in radians)
      color: "blue",
      health: 100,
      maxHealth: 100,
      damage: 1,
      damageStyle: "projectile",
      defenseStyle: "projectile",
      lives: 3,
      lastHit: Date.now(),
      lastMarkHit: Date.now(),
      damaged: false,
    };

    // Handle player movement
    const keys = {};
    window.addEventListener("keydown", (e) => {
      keys[e.key.toLowerCase()] = true;
    });
    window.addEventListener("keyup", (e) => {
      keys[e.key.toLowerCase()] = false;
    });

    // Handle player controls
    function updatePlayer(player) {
      if (!canControl || isGameOver) return; // Skip if the game is over or controls are disabled
      // Calculate the angle between the player and the mouse
      const angleToMouse = Math.atan2(mouseY - player.y, mouseX - player.x);
      player.angle = angleToMouse;

      // Check if the mouse is above the player (on the Y-axis)
      player.isFacingBack = mouseY < player.y;

      // Store the previous position of the player
      const prevX = player.x;
      const prevY = player.y;

      // Move player based on keyboard input
      //move up on the canvas
      if (keys["w"]) {
        player.y -= player.currentSpeed;
      }
      //move down on the canvas
      if (keys["s"]) {
        player.y += player.currentSpeed;
      }
      if (keys["a"]) {
        // Move left on the canvas
        player.x -= player.currentSpeed;
      }

      if (keys["d"]) {
        // Move right on the canvas
        player.x += player.currentSpeed;
      }

      // Boundaries check
      player.x = Math.max(
        player.size / 2,
        Math.min(canvas.width - player.size / 2, player.x),
      );
      player.y = Math.max(
        player.size / 2,
        Math.min(canvas.height - player.size / 2, player.y),
      );

      // Handle collisions with walls
      for (let i = 0; i < walls.length; i++) {
        const wall = walls[i];

        // Check for collision with the wall
        if (
          player.x + player.size / 2 > wall.x &&
          player.x - player.size / 2 < wall.x + wall.width &&
          player.y + player.size / 2 > wall.y &&
          player.y - player.size / 2 < wall.y + wall.height
        ) {
          // If there was a collision, revert the position to where it was before the move
          player.x = prevX;
          player.y = prevY;
          break; // Stop checking other walls once we have resolved this collision
        }
      }

      // Response to player pressing space bar
      if (keys[" "]) {
        // probably activate a dodge or dash on space bar
        keys[" "] = false; // Prevent continuous attacking
      }

      if (attacking) {
        switch (player.damageStyle) {
          case "projectile":
            projectileStrike();
            return;
          case "melee":
            meleeStrikes.push(meleeStrike(player));
            return;
          case "magic":
            magicStrike();
            return;
        }
      }
    }

    // Handle player collision and death
    //handles applying status debuffs, damage, to player

    function handlePlayerDamage(damageRoll) {
      if (isPlayerDead) return; // Stop further execution if the player is already dead
      //check the damage triangle
      const combatCheck = checkCombatTriangle(
        damageRoll.damageStyle,
        player.defenseStyle,
      );

      combatCheck ? (player.health = player.health - damageRoll.damage) : [];

      if (player.health <= 0) {
        isPlayerDead = true;
        canControl = false;
        player.lives--;
        createBloodSplatterEffect(player.x, player.y);

        // If player has no lives left, freeze the game and show the respawn button
        if (player.lives <= 0) {
          isGameOver = true;
        }
        showRespawnButton(); // Show the respawn button

        // Bring focus back to the canvas
        const canvas = document.querySelector("canvas");
        if (canvas) {
          canvas.focus();
        }
      }
    }

    function respawnPlayer() {
      // Reset player position to the center of the canvas
      player.x = canvas.width / 2;
      player.y = canvas.height / 2;

      // Optionally, reset player health or other properties if needed
      player.health = player.maxHealth; // Assuming the player starts with 10 health
      player.lastHitTime = 0; // Reset the cooldown timer if necessary
      marks = [];
      isPlayerDead = false; // Re-enable damage handling
      canControl = true;
      // document.body.removeChild(respawnButton); // Remove the respawn button after clicking
    }

    // Create projectiles on space press
    function projectileStrike() {
      const { x, y, angle } = player;
      const size = 10;
      const speed = player.speed * 3;
      projectiles.push({
        x: x + Math.cos(angle) * (player.size / 2), // Start at the tip of the player
        y: y + Math.sin(angle) * (player.size / 2),
        angle,
        size,
        speed,
        bounced: 0,
      });
    }

    // Magic Strike: Delay before activation at clicked location
    function magicStrike(event) {
      if (!event) return;
      const size = 50; // Size of the magic effect
      const activationDelay = 500; // Delay before activation (in ms)

      // Get mouse position where the user clicked
      const canvas = document.querySelector("canvas");
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;

      // Create a magic strike with delay
      magicStrikes.push({
        x,
        y,
        size,
        active: false, // Initially inactive
        activationTime: Date.now() + activationDelay,
      });
    }

    // Update function to activate magic strikes after delay
    function updateMagicStrikes() {
      const currentTime = Date.now();
      for (let i = 0; i < magicStrikes.length; i++) {
        const strike = magicStrikes[i];

        // Check if the delay has passed and activate the strike
        if (currentTime >= strike.activationTime && !strike.active) {
          strike.active = true; // Activate the strike after delay
          // Optionally: Add a visual effect for the magic strike
        }

        // Optionally: Remove magic strike after a certain time or effect
        // (For example, remove after it lasts for 3 seconds)
        if (strike.active && currentTime - strike.activationTime > 3000) {
          magicStrikes.splice(i, 1);
          i--;
        }
      }
    }

    // Variable to track the currently selected weapon
    let activeWeapon = player.damageStyle;

    // Function to handle cycling between weapons
    function cycleWeapon() {
      if (player.damageStyle === "projectile") {
        player.damageStyle = "melee"; // Cycle to melee
        weaponBox.textContent = player.damageStyle;
        weaponBox.classList.remove("green");
        weaponBox.classList.add("red");
      } else if (player.damageStyle === "melee") {
        player.damageStyle = "magic"; // Cycle to magic
        weaponBox.textContent = player.damageStyle;
        weaponBox.classList.remove("red");
        weaponBox.classList.add("blue");
      } else if (player.damageStyle === "magic") {
        player.damageStyle = "projectile"; // Cycle back to projectile
        weaponBox.textContent = player.damageStyle;
        weaponBox.classList.remove("blue");
        weaponBox.classList.add("green");
      }
      console.log(`Current Weapon: ${player.damageStyle}`); // Log the current weapon for debugging
    }

    // Add event listener for "X" key to cycle weapons
    document.addEventListener("keydown", (event) => {
      if (event.code === "KeyX") {
        cycleWeapon(); // Cycle to the next weapon on pressing "X"
      }
    });

    // Add event listener for attacking based on the active weapon
    // document.addEventListener("keydown", (event) => {
    //   handleAttack(event);
    // });

    // Add mouse event listener for magic strike (which requires a click)
    // document.querySelector("canvas").addEventListener("click", (event) => {
    //   handleAttack(event); // Perform magic strike when canvas is clicked
    // });

    // // Update projectiles
    function updateProjectiles() {
      projectiles = projectiles.filter(
        (p) => p.x > 0 && p.x < canvas.width && p.y > 0 && p.y < canvas.height, // Remove off-screen projectiles
      );

      for (let p of projectiles) {
        p.x += Math.cos(p.angle) * p.speed;
        p.y += Math.sin(p.angle) * p.speed;

        // Check for collision with walls
        const wallHit = checkProjectileCollision(p);
        if (wallHit) {
          if (p.bounced < 1) {
            // Handle bounce if it's the first collision
            handleProjectileBounce(p, wallHit);
          } else {
            // Remove the projectile after bouncing once
            projectiles = projectiles.filter((projectile) => projectile !== p);
          }
        }
      }
    }
    //===============================================================================
    // Function to check if a projectile has collided with a wall (AABB collision detection)
    function checkProjectileCollision(p) {
      for (let wall of walls) {
        if (
          p.x + p.size > wall.x &&
          p.x - p.size < wall.x + wall.width &&
          p.y + p.size > wall.y &&
          p.y - p.size < wall.y + wall.height
        ) {
          return wall; // Return the wall if a collision is detected
        }
      }
      return null; // No collision
    }

    // Function to handle the bouncing of the projectile
    function handleProjectileBounce(p, wall) {
      // Simple bounce logic based on the projectile's angle
      const angleToWall = Math.atan2(
        p.y - (wall.y + wall.height / 2),
        p.x - (wall.x + wall.width / 2),
      );
      p.angle = angleToWall + Math.PI; // Reverse the direction of the projectile (bounce)
      p.bounced += 1;
    }

    //===============================================================================
    // Draw projectiles
    function drawProjectiles() {
      for (let p of projectiles) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fillStyle = "red";
        ctx.fill();
        ctx.closePath();
      }
    }

    //handling melee attacks
    //=================================================================================================================

    // Function to check if a line (melee strike) intersects with any walls
    function checkStrikeWallCollision(m) {
      for (let wall of walls) {
        if (
          m.xStart < wall.x + wall.width &&
          m.xEnd > wall.x && // Check horizontal bounds
          m.yStart < wall.y + wall.height &&
          m.yEnd > wall.y // Check vertical bounds
        ) {
          // Use line intersection logic here, we will return true if it intersects
          if (lineIntersectsRect(m.xStart, m.yStart, m.xEnd, m.yEnd, wall)) {
            return true; // The melee strike intersects with the wall
          }
        }
      }
      return false; // No intersection with any walls
    }

    // Function to check if a line intersects a rectangle (wall)
function lineIntersectsRect(x1, y1, x2, y2, rect) {
  // Check if the line intersects any of the four sides of the rectangle
  const left = rect.x, right = rect.x + rect.width, top = rect.y, bottom = rect.y + rect.height;

  // Check each side of the rectangle (left, right, top, bottom)
  return (
    lineIntersectsLine(x1, y1, x2, y2, left, top, left, bottom) || // Left
    lineIntersectsLine(x1, y1, x2, y2, right, top, right, bottom) || // Right
    lineIntersectsLine(x1, y1, x2, y2, left, top, right, top) || // Top
    lineIntersectsLine(x1, y1, x2, y2, left, bottom, right, bottom) // Bottom
  );
}

// Function to check if two lines intersect and return the point of intersection
function lineIntersectsLine(x1, y1, x2, y2, x3, y3, x4, y4) {
  const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
  if (denom === 0) return null; // Parallel lines, no intersection

  const intersectX = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / denom;
  const intersectY = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / denom;

  // Check if the intersection point is within the bounds of both line segments
  if (
    Math.min(x1, x2) <= intersectX && intersectX <= Math.max(x1, x2) &&
    Math.min(y1, y2) <= intersectY && intersectY <= Math.max(y1, y2) &&
    Math.min(x3, x4) <= intersectX && intersectX <= Math.max(x3, x4) &&
    Math.min(y3, y4) <= intersectY && intersectY <= Math.max(y3, y4)
  ) {
    return { x: intersectX, y: intersectY };
  }
  return null; // No intersection within the segment bounds
}

// Function to check if the melee strike intersects with a wall and return the intersection point
function checkMeleeStrikeIntersection(xStart, yStart, xEnd, yEnd, wall) {
  const wallLeft = wall.x;
  const wallRight = wall.x + wall.width;
  const wallTop = wall.y;
  const wallBottom = wall.y + wall.height;

  // Check each wall edge (left, right, top, bottom) for intersection with the strike
  let intersection = null;
  
  // Left edge
  intersection = lineIntersectsLine(xStart, yStart, xEnd, yEnd, wallLeft, wallTop, wallLeft, wallBottom);
  if (intersection) return intersection;
  
  // Right edge
  intersection = lineIntersectsLine(xStart, yStart, xEnd, yEnd, wallRight, wallTop, wallRight, wallBottom);
  if (intersection) return intersection;
  
  // Top edge
  intersection = lineIntersectsLine(xStart, yStart, xEnd, yEnd, wallLeft, wallTop, wallRight, wallTop);
  if (intersection) return intersection;
  
  // Bottom edge
  intersection = lineIntersectsLine(xStart, yStart, xEnd, yEnd, wallLeft, wallBottom, wallRight, wallBottom);
  if (intersection) return intersection;
  
  return null; // No intersection
}

// Function to update melee strikes and handle wall collisions
// Function to update melee strikes and handle wall collisions
function updateMeleeStrikes() {
  // Filter melee strikes based on their lifetime (within 400ms of the attack timing)
  meleeStrikes = meleeStrikes.filter((m) => Date.now() - m.attackTiming < 400); // Lifetime of melee strike (400ms)

  for (let m of meleeStrikes) {
    // Only calculate the end position of the strike if it's within the 400ms window
    let strikeEndX = m.xStart + Math.cos(m.angle) * 200; // Max range for line
    let strikeEndY = m.yStart + Math.sin(m.angle) * 200;

    // Check for intersection with any wall and stop the strike at the intersection point
    let collisionPoint = null;
    for (let wall of walls) {
      collisionPoint = checkMeleeStrikeIntersection(m.xStart, m.yStart, strikeEndX, strikeEndY, wall);
      if (collisionPoint) {
        // If an intersection is detected, stop the strike at the intersection point
        strikeEndX = collisionPoint.x;
        strikeEndY = collisionPoint.y;
        break; // Stop checking further walls after the first collision
      }
    }

    // Update the strike's end point with the intersection point (if any)
    m.xEnd = strikeEndX;
    m.yEnd = strikeEndY;

    // Check for collision with balls (and handle damage as before)
    for (let ball of balls) {
      const distance = distanceToSegment(ball.x, ball.y, m.xStart, m.yStart, m.xEnd, m.yEnd);
      const combatTimer = Date.now() - ball.lastHit > 200;

      if (distance < ball.radius && combatTimer) {
        ball.lastHit = Date.now();
        if (checkCombatTriangle(player.damageStyle, ball.defense)) {
          ball.health -= 10;
          createParticles(ball.x, ball.y);
        } else {
          toggleDamageStyleErrorMessage();
        }
        if (ball.health <= 0) {
          balls = balls.filter((b) => b !== ball);
        }
      }
    }
  }
}
    //establishes the 'data' & 'runtime' of the attacks.
    //detects if an attack has landed
    //its different than projectiles in that it handles its own collisions
    // function updateMeleeStrikes() {
    //   meleeStrikes = meleeStrikes.filter((m) => {
    //     // Remove melee strikes after some time/distance
    //     return Date.now() - m.attackTiming < 400; // Lifetime of melee strike (400ms)
    //   });

    //   for (let m of meleeStrikes) {
    //     m.xEnd = m.xStart + Math.cos(m.angle) * 200; // Max range for line
    //     m.yEnd = m.yStart + Math.sin(m.angle) * 200;

    //     // Check if the melee strike hits a wall first
    //     if (checkStrikeWallCollision(m)) {
    //       continue; // Skip this melee strike if it hits a wall
    //     }

    //     // Check collision with balls
    //     for (let ball of balls) {
    //       const distance = distanceToSegment(
    //         ball.x,
    //         ball.y,
    //         m.xStart,
    //         m.yStart,
    //         m.xEnd,
    //         m.yEnd,
    //       );

    //       const combatTimer = Date.now() - ball.lastHit > 200; //verifies that damage is dealt in 500ms blocks
    //       // If distance is less than the ball's radius, deal damage
    //       if (distance < ball.radius && combatTimer) {
    //         ball.lastHit = Date.now();

    //         if (checkCombatTriangle(player.damageStyle, ball.defense)) {
    //           console.log(
    //             `The attack style was ${player.damageStyle} and the defence style was ${ball.defense}`,
    //           );
    //           ball.health -= 10; // Reduce ball health by 2 on projectile hit
    //           createParticles(ball.x, ball.y); // Create particles at collision point
    //         } else {
    //           toggleDamageStyleErrorMessage();
    //         }
    //         // Handle damage to ball or other game logic

    //         createParticles(ball.x, ball.y); // Create particles at collision point
    //         // ball.health -= 1; // Example: reduce ball's health

    //         if (ball.health <= 0) {
    //           balls = balls.filter((b) => b !== ball); // Remove ball if health <= 0
    //         }
    //       }
    //     }
    //   }
    // }

    //supporting function to calculate the melee attacks
    function distanceToSegment(px, py, x1, y1, x2, y2) {
      const l2 = (x2 - x1) ** 2 + (y2 - y1) ** 2; // Square of the segment length

      if (l2 === 0) return Math.hypot(px - x1, py - y1); // Line is a point

      // Projection factor 't' onto the line segment
      let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2;
      t = Math.max(0, Math.min(1, t)); // Clamp t to [0, 1] to stay within the segment

      // Closest point on the line segment
      const closestX = x1 + t * (x2 - x1);
      const closestY = y1 + t * (y2 - y1);

      // Distance from the point to the closest point on the segment
      return Math.hypot(px - closestX, py - closestY);
    }

    // Actually shows the attack animation on the screen
    // function drawMeleeStrikes() {
    //   ctx.strokeStyle = "blue"; // Color of the melee strike
    //   ctx.lineWidth = 5; // Set line width for better visibility
    //   for (let m of meleeStrikes) {
    //     ctx.beginPath();
    //     ctx.moveTo(m.xStart, m.yStart);
    //     ctx.lineTo(m.xEnd, m.yEnd); // Draw a line to the end point of the melee strike
    //     ctx.stroke();
    //     ctx.closePath();
    //   }
    // }


// Function to draw the attack on screen
// Function to draw the attack on screen
function drawMeleeStrikes() {
  ctx.strokeStyle = "blue"; // Color of the melee strike
  ctx.lineWidth = 5; // Set line width for better visibility
  for (let m of meleeStrikes) {
    // Only draw if the strike's attack timing is within 400ms
    if (Date.now() - m.attackTiming <= 400) {
      ctx.beginPath();
      ctx.moveTo(m.xStart, m.yStart);
      ctx.lineTo(m.xEnd, m.yEnd); // Draw a line to the adjusted end point (stopping at the wall)
      ctx.stroke();
      ctx.closePath();
    }
  }
}
    //=================================================================================================================

    // Listen for mouse movement to track the mouse position
    canvas.addEventListener("mousemove", (event) => {
      mouseX = event.clientX - canvas.offsetLeft; // Adjust for canvas position
      mouseY = event.clientY - canvas.offsetTop; // Adjust for canvas position
    });

    /*
     *
     * the beginning of handling player attacks
     */
    let attacking = false; // Track if the player is attacking

    // Listen for left mouse button click (mousedown event)
    canvas.addEventListener("mousedown", (event) => {
      if (event.button === 0) {
        // Left mouse button clicked
        attacking = true;
      }
    });

    // Listen for mouse up event to stop attacking (optional)
    canvas.addEventListener("mouseup", (event) => {
      if (event.button === 0) {
        // Left mouse button released
        attacking = false;
      }
    });

    function drawPlayer(ctx, character) {
      ctx.save();
      // Translate to the character's position
      ctx.translate(character.x, character.y);

      ctx.rotate(character.angle);

      if (character.angle < 3.14 && character.angle > 1.7) {
        // Rotate player based on the angle (no added Math.PI)
        // ctx.rotate(2 *character.angle);
        ctx.scale(1, -1); // Flip horizontally
      }
      // if (character.angle > -3.14 && character.angle < -1.97) {

      // }
      if (character.angle >= -1.7 && character.angle < -0.01) {
        ctx.scale(1, -1); // Flip horizontally
      }

      // // Flip horizontally when showing the back
      if (player.isFacingBack) {
        ctx.scale(1, -1); // Mirror vertically to represent the back
      }

      // ctx.rotate(character.angle);
      let fillColor = player.color;
      // Change the fill style if recently hit
      if (Date.now() - character.lastHitTime < 1500) {
        ctx.fillStyle = "rgba(255, 0, 0, 0.5)"; // Semi-transparent red during cooldown
      } else if (character.isFacingBack) {
        fillColor = "black";
        ctx.fillStyle = fillColor; // Turn black when the mouse is above
      } else {
        ctx.fillStyle = character.color;
      }

      // Draw the head (circle)
      ctx.beginPath();
      // ctx.arc(0, -character.height / 2, 15, 0, Math.PI * 2); // Centered around transformed origin
      ctx.arc(0, 0, 15, 0, Math.PI * 2); // Draw the head at the origin (the new translated point)

      ctx.fillStyle = fillColor; // Apply color
      ctx.fill();
      ctx.stroke();

      // Draw the body (line)
      ctx.beginPath();
      // ctx.moveTo(0, -character.height / 2 + 15); // Start just below the head
      // ctx.lineTo(0, character.height / 2 - 20); // Extend to the bottom of the body
      ctx.moveTo(0, 15); // Start just below the head
      ctx.lineTo(0, character.height / 2 - 20); // Extend to the bottom of the body
      ctx.strokeStyle = fillColor; // Apply color
      ctx.lineWidth = 3;
      ctx.stroke();

      // Draw the arms (lines)
      if (player.health >= 10) {
        ctx.beginPath();
        // ctx.moveTo(0, -character.height / 4); // Shoulder height
        // ctx.lineTo(-character.width / 2, -character.height / 8); // Left arm
        // ctx.moveTo(0, -character.height / 4);
        // ctx.lineTo(character.width / 2, -character.height / 8); // Right arm
        ctx.moveTo(0, 15); // Shoulder height
        ctx.lineTo(-character.width / 2, -character.height / 8); // Left arm
        ctx.moveTo(0, 15);
        ctx.lineTo(character.width / 2, -character.height / 8); // Right arm
        ctx.strokeStyle = fillColor; // Apply color
        ctx.stroke();
      } else if (player.health < 7) {
        ctx.beginPath();
        // ctx.moveTo(0, -character.height / 4); // Shoulder height
        // ctx.lineTo(-character.width / 2, -character.height / 8); // Left arm
        ctx.moveTo(0, 15); // Shoulder height
        ctx.lineTo(-character.width / 2, -character.height / 8); // Left arm
        ctx.strokeStyle = fillColor; // Apply color
        ctx.stroke();
      }

      // Draw the legs (lines)
      ctx.beginPath();
      // ctx.moveTo(0, character.height / 2 - 20); // Base of the body
      // ctx.lineTo(-character.width / 4, character.height / 2); // Left leg
      // ctx.moveTo(0, character.height / 2 - 20);
      // ctx.lineTo(character.width / 4, character.height / 2); // Right leg
      ctx.moveTo(0, character.height / 2 - 20); // Base of the body
      ctx.lineTo(-character.width / 4, character.height / 2); // Left leg
      ctx.moveTo(0, character.height / 2 - 20);
      ctx.lineTo(character.width / 4, character.height / 2); // Right leg
      ctx.strokeStyle = fillColor; // Apply color
      ctx.stroke();

      if (!player.isFacingBack) {
        // Front/Back Features
        // Front View: Draw eyes and mouth
        ctx.fillStyle = "red";
        const eyeOffset = player.size / 8;
        const eyeRadius = player.size / 12;

        // Eyes
        ctx.beginPath();
        ctx.arc(
          -eyeOffset,
          -player.size / 2 - player.size / 4 + 25,
          eyeRadius,
          0,
          Math.PI * 2,
        ); // Left eye
        ctx.arc(
          eyeOffset,
          -player.size / 2 - player.size / 4 + 25,
          eyeRadius,
          0,
          Math.PI * 2,
        ); // Right eye
        ctx.fill();

        // Mouth
        ctx.beginPath();
        ctx.arc(
          0,
          -player.size / 2 - player.size / 6 + 30,
          eyeRadius,
          0,
          Math.PI,
        ); // Simple smile
        ctx.strokeStyle = "red";
        ctx.stroke();
      }

      ctx.restore();
    }

    function getRandomNumber(min, max) {
      return Math.random() * (max - min) + min;
    }
    function assignOffenseStyle(color) {
      switch (color) {
        case "green":
          return "projectile";
        case "blue":
          return "melee";
        case "red":
          return "magic";
      }
    }
    function assignDefenseStyle(color) {
      switch (color) {
        case "green":
          return "magic";
        case "blue":
          return "projectile";
        case "red":
          return "melee";
      }
    }

    function assignColor() {
      const roll = Math.floor(getRandomNumber(0, 3));
      switch (roll) {
        case 0:
          return "green";
        case 1:
          return "blue";
        case 2:
          return "red";
      }
    }
    function canvasReset() {
      respawnPlayer();
      projectiles = [];
      balls = [];
      currentLevel++;
      marks = [];
    }
    let numEnemies;
    function levelGenerator(currentLevel) {
      const difficulty = Math.ceil(currentLevel * 1.05 + currentLevel / 2);
      numEnemies = 0.5 * currentLevel * 3;
      for (let i = 0; i < numEnemies; i++) {
        const color = assignColor();
        const damageStyle = assignOffenseStyle(color);
        const damage = 1 + difficulty;
        const defense = assignDefenseStyle(color);
        balls.push({
          x: getRandomNumber(0, canvas.width),
          y: getRandomNumber(0, canvas.width),
          radius: 20,
          vx: getRandomNumber(-5, 5),
          vy: getRandomNumber(-5, 5),
          color,
          damage,
          damageStyle,
          defense,
          lastHit: 0,
          maxHealth: 2.5 * player.health * difficulty,
          health: 2.5 * player.health * difficulty,
        });
      }
    }

    levelGenerator(currentLevel);

    function createParticles(x, y, count = 50) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x,
          y,
          vx: Math.random() * 4 - 2, // Random horizontal speed
          vy: Math.random() * 4 - 2, // Random vertical speed
          life: 100, // Particle lifespan
          lifetime: Math.random() * 20 + 10, // Random lifespan between 10 and 30 frames
          decayRate: 0.05, // Rate at which the particle fades,
          color: "rgba(255, 165, 0, 1dw)",
        });
      }
    }

    // Blood splatter particle object
    function createBloodSplatter(x, y) {
      const bloodParticle = {
        x: x,
        y: y,
        vx: (Math.random() - 0.5) * 4, // Random X velocity
        vy: (Math.random() - 0.5) * 4, // Random Y velocity
        radius: Math.random() * 5 + 2, // Random radius between 2 and 7
        color: `rgba(255, 0, 0, ${Math.random() * 0.8 + 0.2})`, // Random red with alpha
        lifetime: Math.random() * 20 + 10, // Random lifespan between 10 and 30 frames
        decayRate: 0.05, // Rate at which the particle fades
      };

      return bloodParticle;
    }

    // Update blood particles (move, fade, and remove them when they're done)
    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];

        // Move the particle
        particle.x += particle.vx;
        particle.y += particle.vy;

        // Decay the particle (shrink size and reduce opacity)
        particle.lifetime -= particle.decayRate;

        // Remove particle if lifetime is over
        if (particle.lifetime <= 0) {
          particles.splice(i, 1); // Remove the particle from the array
        }
      }
    }

    // Draw particles
    function drawParticles() {
      for (let p of particles) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 2, 0, Math.PI * 4);
        ctx.fillStyle = `rgba(255, 165, 0, ${p.life / 100})`; // Fade out
        ctx.fill();
        ctx.closePath();
      }
    }

    // Draw blood splatter particles
    function drawBloodParticles() {
      for (let particle of particles) {
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
        ctx.fillStyle = particle.color;
        ctx.fill();
        ctx.closePath();
      }
    }

    // Detect collision between two circles
    function isCircleColliding(circle1, circle2) {
      const dx = circle1.x - circle2.x;
      const dy = circle1.y - circle2.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      return distance < circle1.radius + circle2.radius; //makes sense that this would work..
    }

    // Detect collision between two circles
    function isProjectileColliding(circle1, circle2) {
      const dx = circle1.x - circle2.x;
      const dy = circle1.y - circle2.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      return distance <= circle1.radius + circle2.radius;
    }

    // Handle collisions between balls
    function handleBallBallCollisions() {
      for (let i = 0; i < balls.length; i++) {
        for (let j = i + 1; j < balls.length; j++) {
          if (isCircleColliding(balls[i], balls[j])) {
            // Reverse velocities for simple collision response
            const tempVx = balls[i].vx;
            const tempVy = balls[i].vy;
            balls[i].vx = balls[j].vx;
            balls[i].vy = balls[j].vy;
            balls[j].vx = tempVx;
            balls[j].vy = tempVy;
          }
        }
      }
    }

    // // Handle collisions with player
    //handles players being hit with attacks,
    //draining players health
    //inflicting status affects on player
    //
    function handlePlayerCollisions() {
      const currentTime = Date.now();
      const playerRadius = Math.sqrt(
        (player.size / 2) ** 2 + (player.size / 2) ** 2,
      );

      for (let ball of balls) {
        let now = Date.now();
        // Check for cooldown
        //@TODO:
        //this raw 200 should be converted to a property on the balls ,same way it should be for marks
        const combatTimer = now - player.lastHit > 200; //verifies that damage is dealt in 800ms blocks
        const playerHitBox = { x: player.x, y: player.y, radius: playerRadius };
        //convert the radius that was calculated in order to calculate collision of radius's
        if (isCircleColliding(playerHitBox, ball)) {
          if (!combatTimer) return;
          now = Date.now();
          player.lastHit = now;
          const damageRoll = {
            damage: ball.damage,
            damageStyle: ball.damageStyle,
          };
          handlePlayerDamage(damageRoll);
          createParticles(ball.x, ball.y); // Create particles at collision point
          ball.lastHit = currentTime; // Set cooldown timestamp

          //1. check that player combat style is melee
          //apply 1.25x normal damage if ball is weak to melee
          //apply apply 1x damage if ball is normal to melee
          //apply 1 damage if ball is strong against melee

          //not doing damage here
          // ball.health -= 2; // Reduce ball health by 2

          // Update the player's last hit time to initiate the invincibility period
          player.lastHitTime = currentTime;

          if (player.health <= 0) {
            createBloodSplatterEffect(player.x, player.y);
            player.health = 0;
            // respawnPlayer(); // Reset player to the center of the canvas
          }

          if (ball.health <= 0) {
            ball.health = 0;
            handleBallDestruction(ball); // Handle ball destruction (optional)
          }
        }
      }
      for (let mark of marks) {
        // const combatTimer = Date.now() - player.lastHit > 800; //verifies that damage is dealt in 800ms blocks
        let now = Date.now();
        const combatTimer = now - player.lastMarkHit > 50;
        const playerHitBox = { x: player.x, y: player.y, radius: playerRadius };
        if (mark.isActive && isCircleColliding(playerHitBox, mark)) {
          //slow is applied whether the player is taking damage or not
          player.currentSpeed = player.speed * 0.05; // Slow the player to 25% of base speed
          if (!combatTimer) return; //this decides if damage will be taken

          //damage inflicting so reset the hit clock
          now = Date.now();
          player.lastMarkHit = now;
          const damageRoll = {
            damage: mark.damage,
            damageStyle: mark.damageStyle,
          };
          handlePlayerDamage(damageRoll);
          createParticles(mark.x, mark.y);
        } else {
          player.currentSpeed = player.speed;
        }
      }
    }

    // Create multiple blood splatter particles
    function createBloodSplatterEffect(x, y) {
      for (let i = 0; i < 20; i++) {
        // Create 20 particles
        particles.push(createBloodSplatter(x, y)); // Add the particle to the particles array
      }
    }

    // Check for collision between two balls
    function isColliding(ball1, ball2) {
      let dx = ball1.x - ball2.x;
      let dy = ball1.y - ball2.y;
      let distance = Math.sqrt(dx * dx + dy * dy);
      return distance < ball1.radius + ball2.radius;
    }

    // Update ball positions and handle collisions
    function updateBalls() {
      for (let i = 0; i < balls.length; i++) {
        let ball = balls[i];

        // Update position
        ball.x += ball.vx;
        ball.y += ball.vy;

        // Bounce off perimeter
        if (ball.x - ball.radius < 0 || ball.x + ball.radius > canvas.width) {
          ball.vx *= -1;
        }
        if (ball.y - ball.radius < 0 || ball.y + ball.radius > canvas.height) {
          ball.vy *= -1;
        }

        // Handle collision with each wall
        walls.forEach((wall) => {
          // Check for collision with the rectangular wall
          if (
            ball.x + ball.radius > wall.x &&
            ball.x - ball.radius < wall.x + wall.width &&
            ball.y + ball.radius > wall.y &&
            ball.y - ball.radius < wall.y + wall.height
          ) {
            // Bounce off the top or bottom of the wall
            if (ball.x > wall.x && ball.x < wall.x + wall.width) {
              if (ball.y - ball.radius < wall.y) {
                ball.vy *= -1; // Bounce off the top wall
              } else if (ball.y + ball.radius > wall.y + wall.height) {
                ball.vy *= -1; // Bounce off the bottom wall
              }
            }

            // Bounce off the left or right of the wall
            if (ball.y > wall.y && ball.y < wall.y + wall.height) {
              if (ball.x - ball.radius < wall.x) {
                ball.vx *= -1; // Bounce off the left wall
              } else if (ball.x + ball.radius > wall.x + wall.width) {
                ball.vx *= -1; // Bounce off the right wall
              }
            }
          }
        });

        // Check for collisions with other balls
        for (let j = i + 1; j < balls.length; j++) {
          let otherBall = balls[j];
          if (isColliding(ball, otherBall)) {
            // Simple velocity reversal on collision
            ball.vx *= -1;
            ball.vy *= -1;
            otherBall.vx *= -1;
            otherBall.vy *= -1;

            // Create particles at collision point
            createParticles(
              (ball.x + otherBall.x) / 2,
              (ball.y + otherBall.y) / 2,
            );
          }
        }
        //@TODO: check for collisions with projectiles, weapon attacks,
      }
    }

    // Draw balls
    function drawBalls() {
      for (let ball of balls) {
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        ctx.fillStyle = ball.color;
        ctx.fill();
        ctx.closePath();

        // Draw health bar above the ball
        const healthBarWidth = ball.radius * 2 + ball.radius / 2; // Width of the health bar
        const healthBarHeight = 10; // Height of the health bar
        const healthBarX = ball.x - healthBarWidth / 2; // Position horizontally centered on the ball
        const healthBarY = ball.y - ball.radius - 12; // Position the health bar above the ball

        // const healthBarFill = (ball.health / 100) * healthBarWidth; // Proportional fill based on health
        const healthBarFill = (ball.health / ball.maxHealth) * healthBarWidth; // Proportional fill based on health

        // Draw the background of the health bar (empty bar)
        ctx.fillStyle = "#000"; // Black background for the health bar
        ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

        // Draw the filled portion of the health bar (green for health)
        ctx.fillStyle = "red";
        ctx.fillRect(healthBarX, healthBarY, healthBarFill, healthBarHeight);
      }
    }

    function formatHealthValue() {
      if (player.health < 0) {
        return 0;
      }
      return Math.ceil(player.health);
    }
    // Draw health
    function drawHealth() {
      ctx.fillStyle = "black";
      ctx.font = "20px Arial";
      ctx.fillText(
        `Health: ${formatHealthValue()} \n Lives: ${player.lives} FPS: ${currentFPS}`,
        10,
        30,
      );
    }

    function checkCombatTriangle(damageStyle, defenseStyle) {
      return damageStyle !== defenseStyle;
    }

    function toggleDamageStyleErrorMessage() {
      const errorMessageDiv = document.getElementById("errorMessage");
      const currentTime = Date.now(); // Get the current time in milliseconds

      // If the error message is not currently showing OR 3 seconds have passed since last shown
      if (!showError && currentTime - lastErrorTime >= 1000) {
        showError = true;
        lastErrorTime = currentTime; // Update the last error time
        errorMessageDiv.textContent =
          "Target defence blocked your attack! Invalid attack used!";
        errorMessageDiv.classList.remove("hidden");
        errorMessageDiv.classList.add("visible");

        // Hide the error message after 2 seconds
        setTimeout(() => {
          showError = false;
          errorMessageDiv.classList.remove("visible");
          errorMessageDiv.classList.add("hidden");
        }, 2000);
      }
    }

    // Handle player projectile collision with balls
    function handleProjectileCollisions() {
      for (let i = 0; i < projectiles.length; i++) {
        const currentProjectile = projectiles[i];
        console.log(`is this a projectile?? ${currentProjectile}`);
        //calculate radius of the non circle object
        const projectileRadius = Math.sqrt(
          (currentProjectile.size / 2) ** 2 + (currentProjectile.size / 2) ** 2,
        );

        // for (let projectile of projectiles) {
        for (let ball of balls) {
          //convert the radius that was calculated in order to calculate collision of radius's
          if (
            isProjectileColliding(
              {
                x: currentProjectile.x,
                y: currentProjectile.y,
                radius: projectileRadius,
              },
              ball,
            )
          ) {
            if (checkCombatTriangle(player.damageStyle, ball.defense)) {
              console.log(
                `The attack style was ${player.damageStyle} and the defence style was ${ball.defense}`,
              );
              ball.health -= 2; // Reduce ball health by 2 on projectile hit
            } else {
              toggleDamageStyleErrorMessage();
            }

            createParticles(ball.x, ball.y); // Create particles at the collision point
            removeProjectile(projectiles[i]); // Remove the projectile after collision
            if (ball.health <= 0) {
              ball.health = 0;
              handleBallDestruction(ball); // Handle ball destruction (optional)
            }
          }
        }
      }
    }

    // Handle player projectile collision with balls
    //     function handleMeleeCollisions() {
    //       for (let i = 0; i < meleeStrikes.length; i++) {
    //         const currentMelee = meleeStrikes[i];
    // // console.log({currentMelee});
    //         //calculate radius of the non circle object
    //         const meleeRadius = Math.sqrt(
    //           (currentMelee.size / 2) ** 2 + (currentMelee.size / 2) ** 2,
    //         );

    //         // for (let projectile of projectiles) {
    //         for (let ball of balls) {
    //           //convert the radius that was calculated in order to calculate collision of radius's
    //           if (
    //             isProjectileColliding(
    //               {
    //                 x: currentMelee.x,
    //                 y: currentMelee.y,
    //                 radius: meleeRadius,
    //               },
    //               ball,
    //             )
    //           ) {
    //             console.log(
    //               `The attack style was ${player.damageStyle} and the defence style was ${ball.defense}`,
    //             );
    //             if (checkCombatTriangle(player.damageStyle, ball.defense)) {
    //               console.log(
    //                 `The attack style was ${player.damageStyle} and the defence style was ${ball.defense}`,
    //               );
    //               ball.health -= 2; // Reduce ball health by 2 on projectile hit
    //             } else {
    //               toggleDamageStyleErrorMessage();
    //             }

    //             createParticles(ball.x, ball.y); // Create particles at the collision point
    //             removeProjectile(projectiles[i]); // Remove the projectile after collision
    //             if (ball.health <= 0) {
    //               ball.health = 0;
    //               handleBallDestruction(ball); // Handle ball destruction (optional)
    //             }
    //           }
    //         }
    //       }
    //     }

    // Function to remove a projectile from the projectiles array
    function removeProjectile(index) {
      // Remove the projectile at the specified index
      projectiles.splice(index, 1);
    }

    // Optional: Handle ball destruction (e.g., remove the ball when its health reaches 0)
    function handleBallDestruction(ball) {
      const index = balls.indexOf(ball);
      if (index > -1) {
        balls.splice(index, 1); // Remove ball from array
      }
    }

    // Show respawn button
    function showRespawnButton() {
      const existingButton = document.querySelector("button.respawn-button");
      let respawnButton;

      if (existingButton) {
        document.body.removeChild(existingButton);
      } else {
        respawnButton = document.createElement("button");
      }
      // const respawnButton = document.createElement("button");
      respawnButton.innerText = player.lives > 0 ? "Respawn" : "Game Over";
      respawnButton.style.position = "absolute";
      respawnButton.style.top = "50%";
      respawnButton.style.left = "50%";
      respawnButton.style.transform = "translate(-50%, -50%)";
      respawnButton.style.padding = "10px 20px";
      respawnButton.style.fontSize = "20px";
      document.body.appendChild(respawnButton);

      respawnButton.addEventListener("click", () => {
        if (player.lives <= 0) {
          respawnGame();
        } else {
          respawnPlayer();
        }
      });
      // Attach the event listener
      const onClick = () => {
        // Remove the button from the DOM
        if (respawnButton.parentNode) {
          respawnButton.removeEventListener("click", onClick); // Cleanup listener
          document.body.removeChild(respawnButton);
        } else {
          console.warn("Respawn button was already removed or doesn't exist");
        }
      };

      // Add click event listener
      respawnButton.addEventListener("click", onClick);

      // Add click event listener
      respawnButton.addEventListener("click", onClick);
    }

    // Reset the game with 3 lives
    function respawnGame() {
      particles = [];
      marks = [];

      player.lives = 3; // Reset player lives
      player.health = 100; // Reset player health
      isGameOver = false; // Reset game over flag
      canControl = true;
      isPlayerDead = false; // Allow damage handling again
      respawnPlayer(); // Reset player position
      window.location.reload(); // Reload the page to reset the game

      // Optionally reset any other game states here
    }

    weaponBox.textContent = player.damageStyle;
    let lastFrameTime = 0;
    let frameCount = 0;
    let elapsedTime = 0;
    let currentFPS = 0;

    function countFPS(timestamp) {
      if (!lastFrameTime) lastFrameTime = timestamp;
      let deltaTime;
      // Calculate the time since the last frame
      if (lastFrameTime !== timestamp) {
        deltaTime = parseFloat((timestamp - lastFrameTime).toFixed(0));
      }
      lastFrameTime = timestamp;
      if (typeof elapsedTime === "number" && typeof deltaTime === "number") {
        elapsedTime += deltaTime;
      }
      frameCount++;
      // If 1 second (1000ms) has passed, calculate and log FPS
      if (elapsedTime >= 1000) {
        currentFPS = frameCount;
        frameCount = 0;
        elapsedTime = 0;
      }
    }

    //=========================================================================================================

    // Wall size constants for easy adjustment
    const WALL_WIDTH = 8;
    const MIN_DISTANCE = 3 * WALL_WIDTH; // Minimum distance between walls (3 wall widths)

    // Define the canvas size for boundary checking
    const canvasWidth = 1000;
    const canvasHeight = 1000;

    // Define an array to store walls
    let walls = [];

    // Function to check if the new wall overlaps or is too close to any existing walls
    function isWallTooClose(newWall) {
      for (let i = 0; i < walls.length; i++) {
        const existingWall = walls[i];

        // Check if the new wall is too close to any existing wall (within the MIN_DISTANCE)
        if (
          Math.abs(existingWall.x - newWall.x) < MIN_DISTANCE ||
          Math.abs(existingWall.y - newWall.y) < MIN_DISTANCE ||
          Math.abs(
            existingWall.x + existingWall.width - (newWall.x + newWall.width),
          ) < MIN_DISTANCE ||
          Math.abs(
            existingWall.y + existingWall.height - (newWall.y + newWall.height),
          ) < MIN_DISTANCE || Math.abs(
            player.y + player.size - (newWall.y + newWall.height),
          ) < MIN_DISTANCE * 4 ||
          Math.abs(
            player.x + existingWall.height - (newWall.x + newWall.width),
          ) < MIN_DISTANCE * 4
        ) {
          return true; // The new wall is too close to an existing one
        }
      }
      return false; // No walls are too close, the new wall is valid
    }

    // Function to generate a new wall
    function generateWall() {
      let newWall;
      let validWall = false;

      // Try to generate a valid wall until one is found
      while (!validWall) {
        // Randomly generate the coordinates and dimensions for the new wall
        newWall = {
          x: Math.random() * (canvasWidth - WALL_WIDTH), // Random X position
          y: Math.random() * (canvasHeight - WALL_WIDTH), // Random Y position
          width: WALL_WIDTH + Math.random() * 600, // Random width between 20 and 70
          height: WALL_WIDTH + Math.random() * 50, // Random height between 20 and 70
        };

        // Check if the wall respects the minimum distance rule
        validWall = !isWallTooClose(newWall);
      }

      // Once a valid wall is found, add it to the walls array
      walls.push(newWall);
    }

    // Function to draw all walls
    function drawWalls() {
      ctx.fillStyle = "gray"; // Wall color
      ctx.lineWidth = 2;
      ctx.strokeStyle = "black";

      walls.forEach((wall) => {
        ctx.beginPath();
        ctx.rect(wall.x, wall.y, wall.width, wall.height);
        ctx.fill();
        ctx.stroke();
      });
    }

    // Generate a certain number of walls (e.g., 5 walls) ensuring they don't break the rules
    for (let i = 0; i < 5; i++) {
      generateWall();
    }

    // Now draw the walls on the canvas
    drawWalls();
    //=========================================================================================================
    // Main game loop
    function loop(timestamp) {
      if (!isGameOver) {
        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
        countFPS(timestamp);
        drawWalls();
        //update game objects
        updateMarks();
        updatePlayer(player);
        updateBalls();
        updateParticles();
        updateProjectiles();
        updateMeleeStrikes();
        updateMagicStrikes();
        handleBallBallCollisions();
        handlePlayerCollisions();
        handleProjectileCollisions();
        // handleMeleeCollisions();
        //draw game objects

        // drawCharacter(ctx, character); // Draw the character
        drawMarks();
        drawPlayer(ctx, player); // Draw the character
        // drawPlayer();
        drawBalls();
        drawHealth();
        drawProjectiles();
        drawMeleeStrikes();
        drawParticles();
        drawBloodParticles();
      }
      requestAnimationFrame(loop);
    }

    loop();
  </script>
</html>
