<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>canvas game</title>
    <link rel="stylesheet" href="index.css" />
  </head>
  <body>
    <div id="container">
      <canvas id="gameCanvas" width="1000" height="1000"></canvas>
      <div id="errorMessage" class="hidden">Invalid attack used!</div>
      <div id="weapon" class="weaponBox"></div>
    </div>
    <div id="gameMetrics"></div>
  </body>
  <script type="module">
    import { meleeStrike } from "./character_attacks.js";
    import { drawWalls } from "./worldBuilder/wall/draw.js";
    import {
      rollWalls,
      wallMetricDataFormat,
    } from "./worldBuilder/wall/wall.js";
    import {
      drawMarks,
      updateMarks,
      createMark,
    } from "./worldBuilder/mark/mark.js";
    const canvas = document.getElementById("gameCanvas");
    const weaponBox = document.getElementById("weapon");
    const gameMetrics = document.getElementById("gameMetrics");
    weaponBox.classList.add("green");
    const ctx = canvas.getContext("2d");
    let currentLevel = 1;

    let showError = false; // Boolean value to toggle the error message
    let lastErrorTime = 0; // Tracks the last time the error message was triggered
    let isPlayerDead = false; // Flag to prevent multiple executions when health drops to 0

    // Character properties
    // const character = {
    //   x: 200,
    //   y: 200,
    //   width: 50,
    //   height: 100,
    //   speed: 5,
    // };

    // Player Object
    const player = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      width: 50,
      height: 100,
      size: 40,
      speed: 4,
      currentSpeed: 4,
      isSlowed: false,
      angle: 0, // Forward direction (in radians)
      color: "blue",
      health: 100,
      maxHealth: 100,
      damage: 1,
      damageStyle: "projectile",
      defenseStyle: "projectile",
      lives: 3,
      lastHit: Date.now(),
      lastMarkHit: Date.now(),
      damaged: false,
    };

    let marks = []; // Array to store marks
    // Ball objects
    let balls = [];
    // Particle system
    let particles = [];
    // Wall size constants for easy adjustment
    const WALL_WIDTH = 4;
    const MIN_DISTANCE = 10 * WALL_WIDTH + 10; // Minimum distance between walls (3 wall widths)

    // Define the canvas size for boundary checking
    const canvasWidth = 900;
    const canvasHeight = 900;

    // Define an array to store walls
    // let walls = [];
    const wallsPayload = {
      canvas: { width: canvas.width, height: canvas.height },
    };
    let walls = rollWalls(5, wallsPayload);

    function getRandomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    let randomInt = getRandomInt(1, 10);
 
    setInterval(() => {
      marks.push(createMark(canvas, marks));
    }, 1500); // Spawn a mark every 3 seconds

    let canControl = true; // Flag to allow/disallow controls
    let timeoutId; // To store the setTimeout reference for clearing the timeout if needed
    let isGameOver = false; // Flag to track if the game is over

    // Projectiles Array
    let projectiles = [];
    let meleeStrikes = [];
    let magicStrikes = [];

    // Mouse position
    let mouseX = 0;
    let mouseY = 0;

    // Handle player movement
    const keys = {};
    window.addEventListener("keydown", (e) => {
      keys[e.key.toLowerCase()] = true;
    });
    window.addEventListener("keyup", (e) => {
      keys[e.key.toLowerCase()] = false;
    });

    // Handle player controls
    function updatePlayer(player) {
      if (!canControl || isGameOver) return; // Skip if the game is over or controls are disabled
      // Calculate the angle between the player and the mouse
      const angleToMouse = Math.atan2(mouseY - player.y, mouseX - player.x);
      player.angle = angleToMouse;

      // Check if the mouse is above the player (on the Y-axis)
      player.isFacingBack = mouseY < player.y;

      // Store the previous position of the player
      const prevX = player.x;
      const prevY = player.y;

      // Move player based on keyboard input
      //move up on the canvas
      if (keys["w"]) {
        player.y -= player.currentSpeed;
      }
      //move down on the canvas
      if (keys["s"]) {
        player.y += player.currentSpeed;
      }
      if (keys["a"]) {
        // Move left on the canvas
        player.x -= player.currentSpeed;
      }

      if (keys["d"]) {
        // Move right on the canvas
        player.x += player.currentSpeed;
      }

      // Boundaries check
      player.x = Math.max(
        player.size / 2,
        Math.min(canvas.width - player.size / 2, player.x),
      );
      player.y = Math.max(
        player.size / 2,
        Math.min(canvas.height - player.size / 2, player.y),
      );

      // Handle collisions with walls
      for (let i = 0; i < walls.length; i++) {
        const wall = walls[i];

        // Check for collision with the wall
        if (
          player.x + player.size / 2 > wall.x &&
          player.x - player.size / 2 < wall.x + wall.width &&
          player.y + player.size / 2 > wall.y &&
          player.y - player.size / 2 < wall.y + wall.height
        ) {
          // If there was a collision, revert the position to where it was before the move
          player.x = prevX;
          player.y = prevY;
          break; // Stop checking other walls once we have resolved this collision
        }
      }

      // Response to player pressing space bar
      if (keys[" "]) {
        // probably activate a dodge or dash on space bar
        keys[" "] = false; // Prevent continuous attacking
      }

      if (attacking) {
        switch (player.damageStyle) {
          case "projectile":
            projectileStrike();
            return;
          case "melee":
            meleeStrikes.push(meleeStrike(player));
            return;
          case "magic":
            magicStrike();
            return;
        }
      }
    }

    // Handle player collision and death
    //handles applying status debuffs, damage, to player

    function handlePlayerDamage(damageRoll) {
      if (isPlayerDead) return; // Stop further execution if the player is already dead
      //check the damage triangle
      const combatCheck = checkCombatTriangle(
        damageRoll.damageStyle,
        player.defenseStyle,
      );

      combatCheck ? (player.health = player.health - damageRoll.damage) : [];

      if (player.health <= 0) {
        isPlayerDead = true;
        canControl = false;
        player.lives--;
        createBloodSplatterEffect(player.x, player.y);

        // If player has no lives left, freeze the game and show the respawn button
        if (player.lives <= 0) {
          isGameOver = true;
        }
        showRespawnButton(); // Show the respawn button

        // Bring focus back to the canvas
        const canvas = document.querySelector("canvas");
        if (canvas) {
          canvas.focus();
        }
      }
    }

    function respawnPlayer() {
      // Reset player position to the center of the canvas
      player.x = canvas.width / 2;
      player.y = canvas.height / 2;

      // Optionally, reset player health or other properties if needed
      player.health = player.maxHealth; // Assuming the player starts with 10 health
      player.lastHitTime = 0; // Reset the cooldown timer if necessary
      marks = [];
      isPlayerDead = false; // Re-enable damage handling
      canControl = true;
      // document.body.removeChild(respawnButton); // Remove the respawn button after clicking
    }

    // Create projectiles on space press
    function projectileStrike() {
      const { x, y, angle } = player;
      const size = 10;
      const speed = player.speed * 3;
      projectiles.push({
        x: x + Math.cos(angle) * (player.size / 2), // Start at the tip of the player
        y: y + Math.sin(angle) * (player.size / 2),
        angle,
        size,
        speed,
        bounced: 0,
      });
    }

    // Magic Strike: Delay before activation at clicked location
    function magicStrike(event) {
      if (!event) return;
      const size = 50; // Size of the magic effect
      const activationDelay = 500; // Delay before activation (in ms)

      // Get mouse position where the user clicked
      const canvas = document.querySelector("canvas");
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;

      // Create a magic strike with delay
      magicStrikes.push({
        x,
        y,
        size,
        active: false, // Initially inactive
        activationTime: Date.now() + activationDelay,
      });
    }

    // Update function to activate magic strikes after delay
    function updateMagicStrikes() {
      const currentTime = Date.now();
      for (let i = 0; i < magicStrikes.length; i++) {
        const strike = magicStrikes[i];

        // Check if the delay has passed and activate the strike
        if (currentTime >= strike.activationTime && !strike.active) {
          strike.active = true; // Activate the strike after delay
          // Optionally: Add a visual effect for the magic strike
        }

        // Optionally: Remove magic strike after a certain time or effect
        // (For example, remove after it lasts for 3 seconds)
        if (strike.active && currentTime - strike.activationTime > 3000) {
          magicStrikes.splice(i, 1);
          i--;
        }
      }
    }

    // Variable to track the currently selected weapon
    let activeWeapon = player.damageStyle;

    // Function to handle cycling between weapons
    function cycleWeapon() {
      if (player.damageStyle === "projectile") {
        player.damageStyle = "melee"; // Cycle to melee
        weaponBox.textContent = player.damageStyle;
        weaponBox.classList.remove("green");
        weaponBox.classList.add("red");
      } else if (player.damageStyle === "melee") {
        player.damageStyle = "magic"; // Cycle to magic
        weaponBox.textContent = player.damageStyle;
        weaponBox.classList.remove("red");
        weaponBox.classList.add("blue");
      } else if (player.damageStyle === "magic") {
        player.damageStyle = "projectile"; // Cycle back to projectile
        weaponBox.textContent = player.damageStyle;
        weaponBox.classList.remove("blue");
        weaponBox.classList.add("green");
      }
    }

    // Add event listener for "X" key to cycle weapons
    document.addEventListener("keydown", (event) => {
      if (event.code === "KeyX") {
        cycleWeapon(); // Cycle to the next weapon on pressing "X"
      }
    });

    // Add event listener for attacking based on the active weapon
    // document.addEventListener("keydown", (event) => {
    //   handleAttack(event);
    // });

    // Add mouse event listener for magic strike (which requires a click)
    // document.querySelector("canvas").addEventListener("click", (event) => {
    //   handleAttack(event); // Perform magic strike when canvas is clicked
    // });

    // // Update projectiles
    function updateProjectiles() {
      projectiles = projectiles.filter(
        (p) => p.x > 0 && p.x < canvas.width && p.y > 0 && p.y < canvas.height, // Remove off-screen projectiles
      );

      for (let p of projectiles) {
        p.x += Math.cos(p.angle) * p.speed;
        p.y += Math.sin(p.angle) * p.speed;

        // Check for collision with walls
        const wallHit = checkProjectileCollision(p);
        if (wallHit) {
          if (p.bounced < 1) {
            // Handle bounce if it's the first collision
            handleProjectileBounce(p, wallHit);
          } else {
            // Remove the projectile after bouncing once
            projectiles = projectiles.filter((projectile) => projectile !== p);
          }
        }
      }
    }
    //===============================================================================
    // Function to check if a projectile has collided with a wall (AABB collision detection)
    function checkProjectileCollision(p) {
      for (let wall of walls) {
        if (
          p.x + p.size > wall.x &&
          p.x - p.size < wall.x + wall.width &&
          p.y + p.size > wall.y &&
          p.y - p.size < wall.y + wall.height
        ) {
          return wall; // Return the wall if a collision is detected
        }
      }
      return null; // No collision
    }

    // Function to handle the bouncing of the projectile
    function handleProjectileBounce(p, wall) {
      // Simple bounce logic based on the projectile's angle
      const angleToWall = Math.atan2(
        p.y - (wall.y + wall.height / 2),
        p.x - (wall.x + wall.width / 2),
      );
      p.angle = angleToWall + Math.PI; // Reverse the direction of the projectile (bounce)
      p.bounced += 1;
    }

    //===============================================================================
    // Draw projectiles
    function drawProjectiles() {
      for (let p of projectiles) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fillStyle = "red";
        ctx.fill();
        ctx.closePath();
      }
    }

    //handling melee attacks
    //=================================================================================================================

    // Function to check if a line (melee strike) intersects with any walls
    function checkStrikeWallCollision(m) {
      for (let wall of walls) {
        if (
          m.xStart < wall.x + wall.width &&
          m.xEnd > wall.x && // Check horizontal bounds
          m.yStart < wall.y + wall.height &&
          m.yEnd > wall.y // Check vertical bounds
        ) {
          // Use line intersection logic here, we will return true if it intersects
          if (lineIntersectsRect(m.xStart, m.yStart, m.xEnd, m.yEnd, wall)) {
            return true; // The melee strike intersects with the wall
          }
        }
      }
      return false; // No intersection with any walls
    }

    // Function to check if a line intersects a rectangle (wall)
    function lineIntersectsRect(x1, y1, x2, y2, rect) {
      // Check if the line intersects any of the four sides of the rectangle
      const left = rect.x,
        right = rect.x + rect.width,
        top = rect.y,
        bottom = rect.y + rect.height;

      // Check each side of the rectangle (left, right, top, bottom)
      return (
        lineIntersectsLine(x1, y1, x2, y2, left, top, left, bottom) || // Left
        lineIntersectsLine(x1, y1, x2, y2, right, top, right, bottom) || // Right
        lineIntersectsLine(x1, y1, x2, y2, left, top, right, top) || // Top
        lineIntersectsLine(x1, y1, x2, y2, left, bottom, right, bottom) // Bottom
      );
    }

    // Function to check if two lines intersect and return the point of intersection
    function lineIntersectsLine(x1, y1, x2, y2, x3, y3, x4, y4) {
      const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
      if (denom === 0) return null; // Parallel lines, no intersection

      const intersectX =
        ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) /
        denom;
      const intersectY =
        ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) /
        denom;

      // Check if the intersection point is within the bounds of both line segments
      if (
        Math.min(x1, x2) <= intersectX &&
        intersectX <= Math.max(x1, x2) &&
        Math.min(y1, y2) <= intersectY &&
        intersectY <= Math.max(y1, y2) &&
        Math.min(x3, x4) <= intersectX &&
        intersectX <= Math.max(x3, x4) &&
        Math.min(y3, y4) <= intersectY &&
        intersectY <= Math.max(y3, y4)
      ) {
        return { x: intersectX, y: intersectY };
      }
      return null; // No intersection within the segment bounds
    }

    // Function to check if the melee strike intersects with a wall and return the intersection point
    function checkMeleeStrikeIntersection(xStart, yStart, xEnd, yEnd, wall) {
      const wallLeft = wall.x;
      const wallRight = wall.x + wall.width;
      const wallTop = wall.y;
      const wallBottom = wall.y + wall.height;

      // Check each wall edge (left, right, top, bottom) for intersection with the strike
      let intersection = null;

      // Left edge
      intersection = lineIntersectsLine(
        xStart,
        yStart,
        xEnd,
        yEnd,
        wallLeft,
        wallTop,
        wallLeft,
        wallBottom,
      );
      if (intersection) return intersection;

      // Right edge
      intersection = lineIntersectsLine(
        xStart,
        yStart,
        xEnd,
        yEnd,
        wallRight,
        wallTop,
        wallRight,
        wallBottom,
      );
      if (intersection) return intersection;

      // Top edge
      intersection = lineIntersectsLine(
        xStart,
        yStart,
        xEnd,
        yEnd,
        wallLeft,
        wallTop,
        wallRight,
        wallTop,
      );
      if (intersection) return intersection;

      // Bottom edge
      intersection = lineIntersectsLine(
        xStart,
        yStart,
        xEnd,
        yEnd,
        wallLeft,
        wallBottom,
        wallRight,
        wallBottom,
      );
      if (intersection) return intersection;

      return null; // No intersection
    }

    // Function to update melee strikes and handle wall collisions
    // Function to update melee strikes and handle wall collisions
    function updateMeleeStrikes() {
      // Filter melee strikes based on their lifetime (within 400ms of the attack timing)
      meleeStrikes = meleeStrikes.filter(
        (m) => Date.now() - m.attackTiming < 400,
      ); // Lifetime of melee strike (400ms)

      for (let m of meleeStrikes) {
        // Only calculate the end position of the strike if it's within the 400ms window
        let strikeEndX = m.xStart + Math.cos(m.angle) * 200; // Max range for line
        let strikeEndY = m.yStart + Math.sin(m.angle) * 200;

        // Check for intersection with any wall and stop the strike at the intersection point
        let collisionPoint = null;
        for (let wall of walls) {
          collisionPoint = checkMeleeStrikeIntersection(
            m.xStart,
            m.yStart,
            strikeEndX,
            strikeEndY,
            wall,
          );
          if (collisionPoint) {
            // If an intersection is detected, stop the strike at the intersection point
            strikeEndX = collisionPoint.x;
            strikeEndY = collisionPoint.y;
            break; // Stop checking further walls after the first collision
          }
        }

        // Update the strike's end point with the intersection point (if any)
        m.xEnd = strikeEndX;
        m.yEnd = strikeEndY;

        // Check for collision with balls (and handle damage as before)
        for (let ball of balls) {
          const distance = distanceToSegment(
            ball.x,
            ball.y,
            m.xStart,
            m.yStart,
            m.xEnd,
            m.yEnd,
          );
          const combatTimer = Date.now() - ball.lastHit > 200;

          if (distance < ball.radius && combatTimer) {
            ball.lastHit = Date.now();
            if (checkCombatTriangle(player.damageStyle, ball.defense)) {
              ball.health -= 10;
              createParticles(ball.x, ball.y);
            } else {
              toggleDamageStyleErrorMessage();
            }
            if (ball.health <= 0) {
              balls = balls.filter((b) => b !== ball);
            }
          }
        }
      }
    }

    //supporting function to calculate the melee attacks
    function distanceToSegment(px, py, x1, y1, x2, y2) {
      const l2 = (x2 - x1) ** 2 + (y2 - y1) ** 2; // Square of the segment length

      if (l2 === 0) return Math.hypot(px - x1, py - y1); // Line is a point

      // Projection factor 't' onto the line segment
      let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2;
      t = Math.max(0, Math.min(1, t)); // Clamp t to [0, 1] to stay within the segment

      // Closest point on the line segment
      const closestX = x1 + t * (x2 - x1);
      const closestY = y1 + t * (y2 - y1);

      // Distance from the point to the closest point on the segment
      return Math.hypot(px - closestX, py - closestY);
    }

    // Function to draw the attack on screen
    function drawMeleeStrikes() {
      ctx.strokeStyle = "blue"; // Color of the melee strike
      ctx.lineWidth = 5; // Set line width for better visibility
      for (let m of meleeStrikes) {
        // Only draw if the strike's attack timing is within 400ms
        if (Date.now() - m.attackTiming <= 400) {
          ctx.beginPath();
          ctx.moveTo(m.xStart, m.yStart);
          ctx.lineTo(m.xEnd, m.yEnd); // Draw a line to the adjusted end point (stopping at the wall)
          ctx.stroke();
          ctx.closePath();
        }
      }
    }
    //=================================================================================================================

    // Listen for mouse movement to track the mouse position
    canvas.addEventListener("mousemove", (event) => {
      mouseX = event.clientX - canvas.offsetLeft; // Adjust for canvas position
      mouseY = event.clientY - canvas.offsetTop; // Adjust for canvas position
    });

    /*
     *
     * the beginning of handling player attacks
     */
    let attacking = false; // Track if the player is attacking

    // Listen for left mouse button click (mousedown event)
    canvas.addEventListener("mousedown", (event) => {
      if (event.button === 0) {
        // Left mouse button clicked
        attacking = true;
      }
    });

    // Listen for mouse up event to stop attacking (optional)
    canvas.addEventListener("mouseup", (event) => {
      if (event.button === 0) {
        // Left mouse button released
        attacking = false;
      }
    });

    function drawPlayer(ctx, character) {
      ctx.save();
      // Translate to the character's position
      ctx.translate(character.x, character.y);

      ctx.rotate(character.angle);

      if (character.angle < 3.14 && character.angle > 1.7) {
        // Rotate player based on the angle (no added Math.PI)
        ctx.scale(1, -1); // Flip horizontally
      }
      if (character.angle >= -1.7 && character.angle < -0.01) {
        ctx.scale(1, -1); // Flip horizontally
      }
      // // Flip horizontally when showing the back
      if (player.isFacingBack) {
        ctx.scale(1, -1);
      }

      // ctx.rotate(character.angle);
      let fillColor = player.color;
      // Change the fill style if recently hit
      if (Date.now() - character.lastHitTime < 1500) {
        ctx.fillStyle = "rgba(255, 0, 0, 0.5)"; // Semi-transparent red during cooldown
      } else if (character.isFacingBack) {
        fillColor = "black";
        ctx.fillStyle = fillColor; // Turn black when the mouse is above
      } else {
        ctx.fillStyle = character.color;
      }

      // Draw the border around the player (local coordinates)
      if (player.isSlowed) {
        ctx.strokeStyle = "red"; // Border color
        ctx.lineWidth = 3; // Border thickness
        ctx.strokeRect(
          -player.width / 2,
          -player.height / 2,
          player.width,
          player.height,
        );
      }
      // Draw the head (circle)
      ctx.beginPath();
      // ctx.arc(0, -character.height / 2, 15, 0, Math.PI * 2); // Centered around transformed origin
      ctx.arc(0, 0, 15, 0, Math.PI * 2); // Draw the head at the origin (the new translated point)

      ctx.fillStyle = fillColor; // Apply color
      ctx.fill();
      ctx.stroke();

      // Draw the body (line)
      ctx.beginPath();
      // ctx.moveTo(0, -character.height / 2 + 15); // Start just below the head
      // ctx.lineTo(0, character.height / 2 - 20); // Extend to the bottom of the body
      ctx.moveTo(0, 15); // Start just below the head
      ctx.lineTo(0, character.height / 2 - 20); // Extend to the bottom of the body
      ctx.strokeStyle = fillColor; // Apply color
      ctx.lineWidth = 3;
      ctx.stroke();

      // Draw the arms (lines)
      if (player.health >= 10) {
        ctx.beginPath();
        // ctx.moveTo(0, -character.height / 4); // Shoulder height
        // ctx.lineTo(-character.width / 2, -character.height / 8); // Left arm
        // ctx.moveTo(0, -character.height / 4);
        // ctx.lineTo(character.width / 2, -character.height / 8); // Right arm
        ctx.moveTo(0, 15); // Shoulder height
        ctx.lineTo(-character.width / 2, -character.height / 8); // Left arm
        ctx.moveTo(0, 15);
        ctx.lineTo(character.width / 2, -character.height / 8); // Right arm
        ctx.strokeStyle = fillColor; // Apply color
        ctx.stroke();
      } else if (player.health < 7) {
        ctx.beginPath();
        // ctx.moveTo(0, -character.height / 4); // Shoulder height
        // ctx.lineTo(-character.width / 2, -character.height / 8); // Left arm
        ctx.moveTo(0, 15); // Shoulder height
        ctx.lineTo(-character.width / 2, -character.height / 8); // Left arm
        ctx.strokeStyle = fillColor; // Apply color
        ctx.stroke();
      }

      // Draw the legs (lines)
      ctx.beginPath();
      // ctx.moveTo(0, character.height / 2 - 20); // Base of the body
      // ctx.lineTo(-character.width / 4, character.height / 2); // Left leg
      // ctx.moveTo(0, character.height / 2 - 20);
      // ctx.lineTo(character.width / 4, character.height / 2); // Right leg
      ctx.moveTo(0, character.height / 2 - 20); // Base of the body
      ctx.lineTo(-character.width / 4, character.height / 2); // Left leg
      ctx.moveTo(0, character.height / 2 - 20);
      ctx.lineTo(character.width / 4, character.height / 2); // Right leg
      ctx.strokeStyle = fillColor; // Apply color
      ctx.stroke();

      if (!player.isFacingBack) {
        // Front/Back Features
        // Front View: Draw eyes and mouth
        ctx.fillStyle = "red";
        const eyeOffset = player.size / 8;
        const eyeRadius = player.size / 12;

        // Eyes
        ctx.beginPath();
        ctx.arc(
          -eyeOffset,
          -player.size / 2 - player.size / 4 + 25,
          eyeRadius,
          0,
          Math.PI * 2,
        ); // Left eye
        ctx.arc(
          eyeOffset,
          -player.size / 2 - player.size / 4 + 25,
          eyeRadius,
          0,
          Math.PI * 2,
        ); // Right eye
        ctx.fill();

        // Mouth
        ctx.beginPath();
        ctx.arc(
          0,
          -player.size / 2 - player.size / 6 + 30,
          eyeRadius,
          0,
          Math.PI,
        ); // Simple smile
        ctx.strokeStyle = "red";
        ctx.stroke();
      }

      ctx.restore();
    }

    function getRandomNumber(min, max) {
      return Math.random() * (max - min) + min;
    }
    function assignOffenseStyle(color) {
      switch (color) {
        case "green":
          return "projectile";
        case "blue":
          return "melee";
        case "red":
          return "magic";
      }
    }
    function assignDefenseStyle(color) {
      switch (color) {
        case "green":
          return "magic";
        case "blue":
          return "projectile";
        case "red":
          return "melee";
      }
    }

    function assignColor() {
      const roll = Math.floor(getRandomNumber(0, 3));
      switch (roll) {
        case 0:
          return "green";
        case 1:
          return "blue";
        case 2:
          return "red";
      }
    }
    function canvasReset() {
      respawnPlayer();
      projectiles = [];
      balls = [];
      currentLevel++;
      marks = [];
    }
    let numEnemies;
    function levelGenerator(currentLevel) {
      const difficulty = Math.ceil(currentLevel * 1.05 + currentLevel / 2);
      numEnemies = 0.5 * currentLevel * 3;
      for (let i = 0; i < numEnemies; i++) {
        const color = assignColor();
        const damageStyle = assignOffenseStyle(color);
        const damage = 1 + difficulty;
        const defense = assignDefenseStyle(color);
        balls.push({
          x: getRandomNumber(0, canvas.width),
          y: getRandomNumber(0, canvas.width),
          radius: 20,
          vx: getRandomNumber(-5, 5),
          vy: getRandomNumber(-5, 5),
          color,
          damage,
          damageStyle,
          defense,
          lastHit: 0,
          maxHealth: 2.5 * player.health * difficulty,
          health: 2.5 * player.health * difficulty,
        });
      }
    }

    levelGenerator(currentLevel);

    function createParticles(x, y, count = 50) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x,
          y,
          vx: Math.random() * 4 - 2, // Random horizontal speed
          vy: Math.random() * 4 - 2, // Random vertical speed
          life: 100, // Particle lifespan
          lifetime: Math.random() * 20 + 10, // Random lifespan between 10 and 30 frames
          decayRate: 0.05, // Rate at which the particle fades,
          color: "rgba(255, 165, 0, 1dw)",
        });
      }
    }

    // Blood splatter particle object
    function createBloodSplatter(x, y) {
      const bloodParticle = {
        x: x,
        y: y,
        vx: (Math.random() - 0.5) * 4, // Random X velocity
        vy: (Math.random() - 0.5) * 4, // Random Y velocity
        radius: Math.random() * 5 + 2, // Random radius between 2 and 7
        color: `rgba(255, 0, 0, ${Math.random() * 0.8 + 0.2})`, // Random red with alpha
        lifetime: Math.random() * 20 + 10, // Random lifespan between 10 and 30 frames
        decayRate: 0.05, // Rate at which the particle fades
      };

      return bloodParticle;
    }

    // Update blood particles (move, fade, and remove them when they're done)
    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];

        // Move the particle
        particle.x += particle.vx;
        particle.y += particle.vy;

        // Decay the particle (shrink size and reduce opacity)
        particle.lifetime -= particle.decayRate;

        // Remove particle if lifetime is over
        if (particle.lifetime <= 0) {
          particles.splice(i, 1); // Remove the particle from the array
        }
      }
    }

    // Draw particles
    function drawParticles() {
      for (let p of particles) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 2, 0, Math.PI * 4);
        ctx.fillStyle = `rgba(255, 165, 0, ${p.life / 100})`; // Fade out
        ctx.fill();
        ctx.closePath();
      }
    }

    // Draw blood splatter particles
    function drawBloodParticles() {
      for (let particle of particles) {
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
        ctx.fillStyle = particle.color;
        ctx.fill();
        ctx.closePath();
      }
    }

    // Detect collision between two circles
    function isCircleColliding(circle1, circle2) {
      const dx = circle1.x - circle2.x;
      const dy = circle1.y - circle2.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      return distance < circle1.radius + circle2.radius; //makes sense that this would work..
    }

    // Detect collision between two circles
    function isProjectileColliding(circle1, circle2) {
      const dx = circle1.x - circle2.x;
      const dy = circle1.y - circle2.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      return distance <= circle1.radius + circle2.radius;
    }

    // Handle collisions between balls
    function handleBallBallCollisions() {
      for (let i = 0; i < balls.length; i++) {
        for (let j = i + 1; j < balls.length; j++) {
          if (isCircleColliding(balls[i], balls[j])) {
            // Reverse velocities for simple collision response
            const tempVx = balls[i].vx;
            const tempVy = balls[i].vy;
            balls[i].vx = balls[j].vx;
            balls[i].vy = balls[j].vy;
            balls[j].vx = tempVx;
            balls[j].vy = tempVy;
          }
        }
      }
    }

    // // Handle collisions with player
    //handles players being hit with attacks,
    //draining players health
    //inflicting status affects on player
    //
    function handlePlayerCollisions() {
      const currentTime = Date.now();
      const playerRadius = Math.sqrt(
        (player.size / 2) ** 2 + (player.size / 2) ** 2,
      );

      for (let ball of balls) {
        let now = Date.now();
        // Check for cooldown
        //@TODO:
        //this raw 200 should be converted to a property on the balls ,same way it should be for marks
        const combatTimer = now - player.lastHit > 200; //verifies that damage is dealt in 800ms blocks
        const playerHitBox = { x: player.x, y: player.y, radius: playerRadius };
        //convert the radius that was calculated in order to calculate collision of radius's
        if (isCircleColliding(playerHitBox, ball)) {
          if (!combatTimer) return;
          now = Date.now();
          player.lastHit = now;
          const damageRoll = {
            damage: ball.damage,
            damageStyle: ball.damageStyle,
          };
          handlePlayerDamage(damageRoll);
          createParticles(ball.x, ball.y); // Create particles at collision point
          ball.lastHit = currentTime; // Set cooldown timestamp

          //1. check that player combat style is melee
          //apply 1.25x normal damage if ball is weak to melee
          //apply apply 1x damage if ball is normal to melee
          //apply 1 damage if ball is strong against melee

          //not doing damage here
          // ball.health -= 2; // Reduce ball health by 2

          // Update the player's last hit time to initiate the invincibility period
          player.lastHitTime = currentTime;

          if (player.health <= 0) {
            createBloodSplatterEffect(player.x, player.y);
            player.health = 0;
            // respawnPlayer(); // Reset player to the center of the canvas
          }

          if (ball.health <= 0) {
            ball.health = 0;
            handleBallDestruction(ball); // Handle ball destruction (optional)
          }
        }
      }
      for (let mark of marks) {
        // const combatTimer = Date.now() - player.lastHit > 800; //verifies that damage is dealt in 800ms blocks
        let now = Date.now();
        const combatTimer = now - player.lastMarkHit > 50;
        const playerHitBox = { x: player.x, y: player.y, radius: playerRadius };
        if (mark.isActive && isCircleColliding(playerHitBox, mark)) {
          //slow is applied whether the player is taking damage or not
          player.currentSpeed = player.speed * 0.05; // Slow the player to 25% of base speed
          player.isSlowed = true;
          if (!combatTimer) return; //this decides if damage will be taken

          //damage inflicting so reset the hit clock
          now = Date.now();
          player.lastMarkHit = now;
          const damageRoll = {
            damage: mark.damage,
            damageStyle: mark.damageStyle,
          };
          handlePlayerDamage(damageRoll);
          createParticles(mark.x, mark.y);
        } else {
          player.currentSpeed = player.speed;
          player.isSlowed = false;
        }
      }
    }

    // Create multiple blood splatter particles
    function createBloodSplatterEffect(x, y) {
      for (let i = 0; i < 20; i++) {
        // Create 20 particles
        particles.push(createBloodSplatter(x, y)); // Add the particle to the particles array
      }
    }

    // Check for collision between two balls
    function isColliding(ball1, ball2) {
      let dx = ball1.x - ball2.x;
      let dy = ball1.y - ball2.y;
      let distance = Math.sqrt(dx * dx + dy * dy);
      return distance < ball1.radius + ball2.radius;
    }

    // Update ball positions and handle collisions
    function updateBalls() {
      for (let i = 0; i < balls.length; i++) {
        let ball = balls[i];

        // Update position
        ball.x += ball.vx;
        ball.y += ball.vy;

        // Bounce off perimeter
        if (ball.x - ball.radius < 0 || ball.x + ball.radius > canvas.width) {
          ball.vx *= -1;
        }
        if (ball.y - ball.radius < 0 || ball.y + ball.radius > canvas.height) {
          ball.vy *= -1;
        }

        // Handle collision with each wall
        walls.forEach((wall) => {
          // Check for collision with the rectangular wall
          if (
            ball.x + ball.radius > wall.x &&
            ball.x - ball.radius < wall.x + wall.width &&
            ball.y + ball.radius > wall.y &&
            ball.y - ball.radius < wall.y + wall.height
          ) {
            // Bounce off the top or bottom of the wall
            if (ball.x > wall.x && ball.x < wall.x + wall.width) {
              if (ball.y - ball.radius < wall.y) {
                ball.vy *= -1; // Bounce off the top wall
              } else if (ball.y + ball.radius > wall.y + wall.height) {
                ball.vy *= -1; // Bounce off the bottom wall
              }
            }

            // Bounce off the left or right of the wall
            if (ball.y > wall.y && ball.y < wall.y + wall.height) {
              if (ball.x - ball.radius < wall.x) {
                ball.vx *= -1; // Bounce off the left wall
              } else if (ball.x + ball.radius > wall.x + wall.width) {
                ball.vx *= -1; // Bounce off the right wall
              }
            }
          }
        });

        // Check for collisions with other balls
        for (let j = i + 1; j < balls.length; j++) {
          let otherBall = balls[j];
          if (isColliding(ball, otherBall)) {
            // Simple velocity reversal on collision
            ball.vx *= -1;
            ball.vy *= -1;
            otherBall.vx *= -1;
            otherBall.vy *= -1;

            // Create particles at collision point
            createParticles(
              (ball.x + otherBall.x) / 2,
              (ball.y + otherBall.y) / 2,
            );
          }
        }
        //@TODO: check for collisions with projectiles, weapon attacks,
      }
    }

    // Draw balls
    function drawBalls() {
      for (let ball of balls) {
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        ctx.fillStyle = ball.color;
        ctx.fill();
        ctx.closePath();

        // Draw health bar above the ball
        const healthBarWidth = ball.radius * 2 + ball.radius / 2; // Width of the health bar
        const healthBarHeight = 10; // Height of the health bar
        const healthBarX = ball.x - healthBarWidth / 2; // Position horizontally centered on the ball
        const healthBarY = ball.y - ball.radius - 12; // Position the health bar above the ball

        // const healthBarFill = (ball.health / 100) * healthBarWidth; // Proportional fill based on health
        const healthBarFill = (ball.health / ball.maxHealth) * healthBarWidth; // Proportional fill based on health

        // Draw the background of the health bar (empty bar)
        ctx.fillStyle = "#000"; // Black background for the health bar
        ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

        // Draw the filled portion of the health bar (green for health)
        ctx.fillStyle = "red";
        ctx.fillRect(healthBarX, healthBarY, healthBarFill, healthBarHeight);
      }
    }

    function formatHealthValue() {
      if (player.health < 0) {
        return 0;
      }
      return Math.ceil(player.health);
    }
    // Draw health
    function drawHealth() {
      ctx.fillStyle = "white";
      if (player.health < 30) {
        ctx.fillStyle = "red";
      }
      ctx.fillRect(0, 0, canvas.width, 0); // Adjust the height as needed

      ctx.font = "40px Arial";
      ctx.fillText(
        `Health: ${formatHealthValue()} \n Lives: ${player.lives} FPS: ${currentFPS}`,
        10,
        30,
      );
    }

    function checkCombatTriangle(damageStyle, defenseStyle) {
      return damageStyle !== defenseStyle;
    }

    function toggleDamageStyleErrorMessage() {
      const errorMessageDiv = document.getElementById("errorMessage");
      const currentTime = Date.now(); // Get the current time in milliseconds

      // If the error message is not currently showing OR 3 seconds have passed since last shown
      if (!showError && currentTime - lastErrorTime >= 1000) {
        showError = true;
        lastErrorTime = currentTime; // Update the last error time
        errorMessageDiv.textContent =
          "Target defence blocked your attack!\n Press X to swap attack style!";
        errorMessageDiv.classList.remove("hidden");
        errorMessageDiv.classList.add("visible");

        // Hide the error message after 2 seconds
        setTimeout(() => {
          showError = false;
          errorMessageDiv.classList.remove("visible");
          errorMessageDiv.classList.add("hidden");
        }, 2000);
      }
    }

    // Handle player projectile collision with balls
    function handleProjectileCollisions() {
      for (let i = 0; i < projectiles.length; i++) {
        const currentProjectile = projectiles[i];
        //calculate radius of the non circle object
        const projectileRadius = Math.sqrt(
          (currentProjectile.size / 2) ** 2 + (currentProjectile.size / 2) ** 2,
        );

        // for (let projectile of projectiles) {
        for (let ball of balls) {
          //convert the radius that was calculated in order to calculate collision of radius's
          if (
            isProjectileColliding(
              {
                x: currentProjectile.x,
                y: currentProjectile.y,
                radius: projectileRadius,
              },
              ball,
            )
          ) {
            if (checkCombatTriangle(player.damageStyle, ball.defense)) {
              ball.health -= 2; // Reduce ball health by 2 on projectile hit
            } else {
              toggleDamageStyleErrorMessage();
            }

            createParticles(ball.x, ball.y); // Create particles at the collision point
            removeProjectile(projectiles[i]); // Remove the projectile after collision
            if (ball.health <= 0) {
              ball.health = 0;
              handleBallDestruction(ball); // Handle ball destruction (optional)
            }
          }
        }
      }
    }

    // Handle player projectile collision with balls
    //     function handleMeleeCollisions() {
    //       for (let i = 0; i < meleeStrikes.length; i++) {
    //         const currentMelee = meleeStrikes[i];
    // // console.log({currentMelee});
    //         //calculate radius of the non circle object
    //         const meleeRadius = Math.sqrt(
    //           (currentMelee.size / 2) ** 2 + (currentMelee.size / 2) ** 2,
    //         );

    //         // for (let projectile of projectiles) {
    //         for (let ball of balls) {
    //           //convert the radius that was calculated in order to calculate collision of radius's
    //           if (
    //             isProjectileColliding(
    //               {
    //                 x: currentMelee.x,
    //                 y: currentMelee.y,
    //                 radius: meleeRadius,
    //               },
    //               ball,
    //             )
    //           ) {
    //             console.log(
    //               `The attack style was ${player.damageStyle} and the defence style was ${ball.defense}`,
    //             );
    //             if (checkCombatTriangle(player.damageStyle, ball.defense)) {
    //               console.log(
    //                 `The attack style was ${player.damageStyle} and the defence style was ${ball.defense}`,
    //               );
    //               ball.health -= 2; // Reduce ball health by 2 on projectile hit
    //             } else {
    //               toggleDamageStyleErrorMessage();
    //             }

    //             createParticles(ball.x, ball.y); // Create particles at the collision point
    //             removeProjectile(projectiles[i]); // Remove the projectile after collision
    //             if (ball.health <= 0) {
    //               ball.health = 0;
    //               handleBallDestruction(ball); // Handle ball destruction (optional)
    //             }
    //           }
    //         }
    //       }
    //     }

    // Function to remove a projectile from the projectiles array
    function removeProjectile(index) {
      // Remove the projectile at the specified index
      projectiles.splice(index, 1);
    }

    // Optional: Handle ball destruction (e.g., remove the ball when its health reaches 0)
    function handleBallDestruction(ball) {
      const index = balls.indexOf(ball);
      if (index > -1) {
        balls.splice(index, 1); // Remove ball from array
      }
    }

    // Show respawn button
    function showRespawnButton() {
      const existingButton = document.querySelector("button.respawn-button");
      let respawnButton;

      if (existingButton) {
        document.body.removeChild(existingButton);
      } else {
        respawnButton = document.createElement("button");
      }
      // const respawnButton = document.createElement("button");
      respawnButton.innerText = player.lives > 0 ? "Respawn" : "Game Over";
      respawnButton.style.position = "absolute";
      respawnButton.style.top = "50%";
      respawnButton.style.left = "50%";
      respawnButton.style.transform = "translate(-50%, -50%)";
      respawnButton.style.padding = "10px 20px";
      respawnButton.style.fontSize = "20px";
      document.body.appendChild(respawnButton);

      respawnButton.addEventListener("click", () => {
        if (player.lives <= 0) {
          respawnGame();
        } else {
          respawnPlayer();
        }
      });
      // Attach the event listener
      const onClick = () => {
        // Remove the button from the DOM
        if (respawnButton.parentNode) {
          respawnButton.removeEventListener("click", onClick); // Cleanup listener
          document.body.removeChild(respawnButton);
        } else {
          console.warn("Respawn button was already removed or doesn't exist");
        }
      };

      // Add click event listener
      respawnButton.addEventListener("click", onClick);

      // Add click event listener
      respawnButton.addEventListener("click", onClick);
    }

    // Reset the game with 3 lives
    function respawnGame() {
      particles = [];
      marks = [];

      player.lives = 3; // Reset player lives
      player.health = 100; // Reset player health
      isGameOver = false; // Reset game over flag
      canControl = true;
      isPlayerDead = false; // Allow damage handling again
      respawnPlayer(); // Reset player position
      window.location.reload(); // Reload the page to reset the game

      // Optionally reset any other game states here
    }

    weaponBox.textContent = player.damageStyle;
    let lastFrameTime = 0;
    let frameCount = 0;
    let elapsedTime = 0;
    let currentFPS = 0;

    function countFPS(timestamp) {
      if (!lastFrameTime) lastFrameTime = timestamp;
      let deltaTime;
      // Calculate the time since the last frame
      if (lastFrameTime !== timestamp) {
        deltaTime = parseFloat((timestamp - lastFrameTime).toFixed(0));
      }
      lastFrameTime = timestamp;
      if (typeof elapsedTime === "number" && typeof deltaTime === "number") {
        elapsedTime += deltaTime;
      }
      frameCount++;
      // If 1 second (1000ms) has passed, calculate and log FPS
      if (elapsedTime >= 1000) {
        currentFPS = frameCount;
        frameCount = 0;
        elapsedTime = 0;
      }
    }

    //=========================================================================================================
    // Store the x-offsets for scrolling
    let terrainOffsetX = 0;
    let cloudOffsetX = 0;
    // Store the x-offset for scrolling
    let offsetX = 0;

    // Generate persistent objects
    const rocks = Array.from({ length: 10 }, () => ({
      x: Math.random() * canvas.width * 2,
      y: canvas.height - 100 + Math.random() * 20,
      radius: Math.random() * 10 + 5,
    }));

    const flowers = Array.from({ length: 5 }, () => ({
      x: Math.random() * canvas.width * 2,
      y: canvas.height - 110 + Math.random() * 10,
    }));

    const clouds = Array.from({ length: 6 }, () => ({
      x: Math.random() * canvas.width * 2,
      y: Math.random() * 100, // Clouds appear in the top 100px
      width: Math.random() * 100 + 50, // Random width
      height: Math.random() * 30 + 20, // Random height
      opacity: Math.random() * 0.5 + 0.5, // Semi-transparent
    }));

    function drawTerrain() {
      // Draw the sky
      ctx.fillStyle = "#87CEEB"; // Light blue for sky
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw clouds
      clouds.forEach((cloud) => {
        let cloudX =
          (cloud.x - offsetX + canvas.width * 2) % (canvas.width * 2);
        ctx.globalAlpha = cloud.opacity; // Set opacity
        ctx.fillStyle = "#FFFFFF"; // White for clouds
        ctx.beginPath();
        ctx.ellipse(
          cloudX,
          cloud.y,
          cloud.width / 2,
          cloud.height / 2,
          0,
          0,
          Math.PI * 2,
        );
        ctx.fill();
        ctx.globalAlpha = 1; // Reset opacity
      });

      // Draw the ground
      ctx.fillStyle = "#6B8E23"; // Olive green for grass
      ctx.fillRect(0, canvas.height - 100, canvas.width, 100);

      // Add details to the ground
      ctx.fillStyle = "#8B4513"; // Brown for dirt layer
      ctx.fillRect(0, canvas.height - 120, canvas.width, 20);

      // Add grass blades
      for (let i = 0; i < canvas.width; i += 10) {
        ctx.beginPath();
        ctx.moveTo(i, canvas.height - 100);
        ctx.lineTo(i + 5, canvas.height - 110);
        ctx.lineTo(i + 10, canvas.height - 100);
        ctx.closePath();
        ctx.fillStyle = "#228B22"; // Forest green for grass blades
        ctx.fill();
      }

      // Define movement speeds
      const terrainSpeed = 2; // Speed for terrain
      const cloudSpeed = 0.5; // Slower speed for clouds

      // Draw clouds
      clouds.forEach((cloud) => {
        const cloudX =
          (cloud.x - offsetX + canvas.width * 2) % (canvas.width * 2);
        ctx.globalAlpha = cloud.opacity; // Set opacity
        ctx.fillStyle = "#FFFFFF"; // White for clouds
        ctx.beginPath();
        ctx.ellipse(
          cloudX,
          cloud.y,
          cloud.width / 2,
          cloud.height / 2,
          0,
          0,
          Math.PI * 2,
        );
        ctx.fill();
        ctx.globalAlpha = 1; // Reset opacity
      });
      // Draw rocks
      rocks.forEach((rock) => {
        const rockX =
          (rock.x - offsetX + canvas.width * 2) % (canvas.width * 2);
        ctx.beginPath();
        ctx.arc(rockX, rock.y, rock.radius, 0, Math.PI * 2);
        ctx.fillStyle = "#808080"; // Gray for rocks
        ctx.fill();
      });

      // Draw flowers
      flowers.forEach((flower) => {
        const flowerX =
          (flower.x - offsetX + canvas.width * 2) % (canvas.width * 2);
        ctx.fillStyle = "#FF69B4"; // Pink for flower petals
        ctx.beginPath();
        ctx.arc(flowerX, flower.y, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#FFD700"; // Yellow for flower center
        ctx.beginPath();
        ctx.arc(flowerX, flower.y, 1.5, 0, Math.PI * 2);
        ctx.fill();
      });

      //these two functions will cause these things to look likt heyre scrolling by
      // // Add rocks
      // for (let i = 0; i < 10; i++) {
      //     const rockX = Math.random() * canvas.width;
      //     const rockY = canvas.height - 100 + Math.random() * 20;
      //     const rockRadius = Math.random() * 10 + 5;
      //     ctx.beginPath();
      //     ctx.arc(rockX, rockY, rockRadius, 0, Math.PI * 2);
      //     ctx.fillStyle = "#808080"; // Gray for rocks
      //     ctx.fill();
      // }

      // // Add flowers
      // for (let i = 0; i < 5; i++) {
      //     const flowerX = Math.random() * canvas.width;
      //     const flowerY = canvas.height - 110 + Math.random() * 10;
      //     ctx.fillStyle = "#FF69B4"; // Pink for flower petals
      //     ctx.beginPath();
      //     ctx.arc(flowerX, flowerY, 3, 0, Math.PI * 2);
      //     ctx.fill();
      //     ctx.fillStyle = "#FFD700"; // Yellow for flower center
      //     ctx.beginPath();
      //     ctx.arc(flowerX, flowerY, 1.5, 0, Math.PI * 2);
      //     ctx.fill();
      // }
    }

    let wallData;

    if (walls.length) {
      wallData = wallMetricDataFormat(walls);
    }

    //=========================================================================================================
    // Main game loop
    function loop(timestamp) {
      if (!isGameOver) {
        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
        clouds.forEach((cloud) => {
          cloud.x++;
        });
        if (wallData) {
          gameMetrics.innerHTML = `
        player.x : ${player.x} <br>
        player.y: ${player.y} <br>
    ${wallData}
        `;
        }
        countFPS(timestamp);
        //update game objects
        marks = updateMarks(ctx, marks);
        updatePlayer(player);
        updateBalls();
        updateParticles();
        updateProjectiles();
        updateMeleeStrikes();
        updateMagicStrikes();
        handleBallBallCollisions();
        handlePlayerCollisions();
        handleProjectileCollisions();
        // handleMeleeCollisions();
        //draw game objects

        // drawCharacter(ctx, character); // Draw the character
        drawTerrain();
        drawMarks(ctx, marks);
        drawPlayer(ctx, player); // Draw the character
        drawWalls(walls, ctx);
        // drawPlayer();
        drawBalls();
        drawHealth();
        drawProjectiles();
        drawMeleeStrikes();
        drawParticles();
        drawBloodParticles();
      }
      requestAnimationFrame(loop);
    }

    loop();
  </script>
</html>
